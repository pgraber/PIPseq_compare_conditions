---
title: "compare_conditions"
toc: true
format:
  html:
    code-fold: false
    code-tools: true
    self-contained: true
    number-sections: true
    theme: flatly
    lightbox: true
execute: 
  output: false
  error: false
  warning: false
  echo: false
project:
  execute-dir: journal
---

```{r, setup, include=FALSE}
library(knitr)
library(here)
library(Seurat)
library(ggVennDiagram)
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(viridis)
library(patchwork)
library(svglite)
library(glmGamPoi)
library(RColorBrewer)
library(readxl)
library(clusterProfiler)
library(org.Hs.eg.db)
library(cowplot)
library(purrr)
library(cowplot)
library(ggrepel)
library(ComplexHeatmap)
library(circlize)

opts_knit$set(root.dir = here())
```

```{r}
seurat_neurospheres <- readRDS(here("data/seurat_neurospheres.rds"))
seurat_bioinert <- readRDS(here("data/seurat_bioinert.rds"))
seurat_biofunctional <- readRDS(here("data/seurat_biofunctional.rds"))
```

```{r}
# 1) Load & tag
NS         <- readRDS(here("data/seurat_neurospheres.rds"))
BP_Control <- readRDS(here("data/seurat_bioinert.rds"))
BP_Cues    <- readRDS(here("data/seurat_biofunctional.rds"))

NS$condition         <- "NS"
BP_Control$condition <- "BP_Control"
BP_Cues$condition    <- "BP_Cues"

# 2) Merge to one object
obj <- merge(NS, y = list(BP_Control, BP_Cues))
DefaultAssay(obj) <- "RNA"

obj[["RNA"]] <- JoinLayers(obj[["RNA"]])
obj[["RNA"]] <- split(obj[["RNA"]], f = obj$condition)

# 2) Unintegrated workflow (as in the vignette)
DefaultAssay(obj) <- "RNA"
obj <- NormalizeData(obj)
obj <- FindVariableFeatures(obj)
obj <- ScaleData(obj)
obj <- RunPCA(obj)
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca")
obj <- FindClusters(obj, resolution = 2, cluster.name = "unintegrated_clusters")
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")

# 3) Integrate layers (adds an integrated reduction)
obj <- IntegrateLayers(
  object         = obj,
  method         = CCAIntegration,
  orig.reduction = "pca",
  new.reduction  = "integrated.cca",
  verbose        = FALSE
)

# 4) Neighbors / clusters / UMAP on the integrated reduction
obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30)
obj <- FindClusters(obj, resolution = 0.6)
obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca")
```




```{r}
saveRDS(obj, file = here("data/processed/integrated_seurat.rds"))
```

```{r}

integrated_obj <- readRDS(here("data/processed/integrated_seurat.rds"))

# 4) Neighbors / clusters / UMAP on the integrated reduction
integrated_obj <- FindNeighbors(integrated_obj, reduction = "integrated.cca", dims = 1:30)
integrated_obj <- FindClusters(integrated_obj, resolution = 0.6)

integrated_obj <- RunUMAP(
  integrated_obj,
  reduction      = "integrated.cca",
  dims           = 1:30,
  reduction.name = "umap_res0.6",  
  reduction.key  = "UMAP06_",
  verbose        = FALSE
)

condition_colors <- c("NS" = "#808080",      
                           "BP_Control" = "#0072B2", 
                           "BP_Cues" = "#D55E00") 
condition_order <- c("NS", "BP_Control", "BP_Cues")

integrated_obj$condition <- factor(integrated_obj$condition, levels = condition_order)

plot_A <- DimPlot(integrated_obj, 
                  reduction = "umap_res0.6", 
                  group.by = "condition",
                  cols = condition_colors,
                  label = FALSE) + 
  ggtitle("A. Integrated UMAP (Colored by Condition)") +
  theme(plot.title = element_text(face = "bold", size = 14))

plot_B <- DimPlot(integrated_obj, 
                  reduction = "umap_res0.6", 
                  group.by = "condition",
                  cols = condition_colors, 
                  split.by = "condition",
                  label = FALSE) +
  ggtitle("B. UMAP Split by Condition (Visualizing Structure)") +
  theme(plot.title = element_text(face = "bold", size = 14))




ggsave(plot = plot_A, filename = here("output/umap_by_condition.pdf"), height = 8, width = 10)

ggsave(plot = plot_B, filename = here("output/umap_by_condition_split.pdf"), height = 8, width = 10)
```

```{r}

n_clusters <- length(unique(integrated_obj$seurat_clusters))

base_colors <- c(brewer.pal(n = 12, name = "Set3"), 
                 brewer.pal(n = 12, name = "Paired"))

cluster_colors <- colorRampPalette(base_colors)(n_clusters)

umap_clusters <- DimPlot(integrated_obj, 
                  reduction = "umap_res0.6", 
                  group.by = "seurat_clusters",
                  cols = cluster_colors,
                  label = TRUE, 
                  repel = TRUE) + 
  ggtitle("Figure 2. Integrated UMAP (Colored by Cluster ID)") +
  theme(plot.title = element_text(face = "bold", size = 14),
        legend.position = "right") 

ggsave(umap_clusters, filename = here("output/umap_by_cluster.pdf"), height = 8, width = 10)

```

```{r}
DefaultAssay(integrated_obj) <- "RNA"

integrated_obj[["RNA"]] <- JoinLayers(integrated_obj[["RNA"]])

all_cluster_markers <- FindAllMarkers(
  object = integrated_obj, 
  only.pos = TRUE,         
  min.pct = 0.1,           
  logfc.threshold = 0.25,
  assay = "RNA"
)

top3_markers <- all_cluster_markers %>%
  group_by(cluster) %>%
  slice_max(n = 3, order_by = avg_log2FC)

genes_to_plot <- unique(top3_markers$gene)


cluster_markers_umap <- DotPlot(integrated_obj, 
                  features = genes_to_plot, 
                  cols = c("lightgrey", "#D55E00"),
                  dot.scale = 8) + 
  RotatedAxis() +
  ggtitle("Figure 3. Top Marker Gene Expression Across Cell Clusters") +
  theme(plot.title = element_text(face = "bold", size = 14),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 10))

ggsave(cluster_markers_umap, filename = here("output/cluster_markers_umap.pdf"), height = 8, width = 12)

```




```{r}
markers_filtered <- all_cluster_markers %>%
  filter(p_val_adj < 0.05, avg_log2FC > 0.25)

top_markers <- markers_filtered %>%
  group_by(cluster) %>%
  slice_max(order_by = avg_log2FC, n = 50)

# convert gene symbols to Entrez IDs
cluster_list <- split(top_markers$gene, top_markers$cluster)

enrich_results <- lapply(names(cluster_list), function(clust) {
  genes <- cluster_list[[clust]]
  genes_entrez <- bitr(genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
  
  ego <- enrichGO(
    gene         = genes_entrez$ENTREZID,
    OrgDb        = org.Hs.eg.db,
    ont          = "BP",
    readable     = TRUE,
    pAdjustMethod = "BH",
    qvalueCutoff = 0.05
  )
  ego@result$Cluster <- clust
  return(ego@result)
})

# combine into one dataframe
enrich_df <- do.call(rbind, enrich_results)

```

```{r}
enrich_df <- enrich_df %>% filter(!is.na(p.adjust))

# top 3 terms per cluster by smallest adjusted p-value
top_terms <- enrich_df %>%
  group_by(Cluster) %>%
  slice_min(order_by = p.adjust, n = 3, with_ties = FALSE) %>%
  ungroup() %>%
  dplyr::select(Cluster, Description, p.adjust, GeneRatio, Count)

top_terms

```





## Label Transfer

```{r}
# --- File paths ---
integrated_obj_path <- here("data/processed/integrated_seurat.rds")
reference_matrix_path <- here("data/Filbin_GSE184357/counts_fresh_postFilter.txt") 
reference_metadata_path <- here("data/Filbin_GSE184357/metadata_fresh_postFilter.txt") 

reference_seurat_obj_output <- here("output/filbin_reference_seurat_obj.rds")
labeled_seurat_obj_output <- here("output/labeled_integrated_obj.rds") 
label_plot_output <- here("output/label_plot_raw.pdf")
score_plot_output <- here("output/score_plot.pdf")
violin_plot_output <- here("output/violin_plot.pdf")
confident_plot_output <- here("output/confident_plot.pdf")

# --- Parameters ---
dims <- 30
prediction_score_threshold <- 0.5
annotation_column <- "annotation"
filter_values <- c("G2M", "S") 
umap_width <- 12 
umap_height <- 10 

# --- Custom color palette for all labels ---
custom_palette <- c(
    "AC-like"     = "#1b9e77",  # dark teal
    "MES-like"    = "#d95f02",  # burnt orange
    "Microglia"   = "#7570b3",  # purple
    "OC-like"     = "#e7298a",  # pink
    "OPC-like-1"  = "#66a61e",  # green
    "OPC-like-2"  = "#e6ab02",  # yellow-orange
    "OPC-like-3"  = "#a6761d"   # brown
)

# --- Load Seurat object ---
integrated_obj <- readRDS(integrated_obj_path)

# --- Load reference ---
reference_matrix <- read.table(reference_matrix_path, header = TRUE, sep = "\t", row.names = 1)
reference_metadata <- read.table(reference_metadata_path, header = TRUE, sep = "\t", row.names = 1)

reference <- CreateSeuratObject(counts = reference_matrix)
reference <- AddMetaData(reference, metadata = reference_metadata)

# --- Filter reference cells ---
if (length(filter_values) > 0) {
    cells_to_keep_anno <- !(reference@meta.data[[annotation_column]] %in% filter_values)
    reference <- subset(reference, cells = rownames(reference@meta.data)[cells_to_keep_anno])
}

# --- Shared genes ---
shared_genes <- intersect(rownames(reference), rownames(integrated_obj))

# --- SCTransform + PCA ---
reference <- SCTransform(reference, verbose = FALSE)
reference <- RunPCA(reference, verbose = FALSE, features = shared_genes)

# --- Save reference object ---
saveRDS(reference, reference_seurat_obj_output)

# --- Transfer anchors & labels ---
anchors <- FindTransferAnchors(
    reference = reference,
    query = integrated_obj, 
    dims = 1:dims,
    features = shared_genes,
    normalization.method = "SCT"
)

predicted_labels <- TransferData(
    anchorset = anchors,
    refdata = reference@meta.data[[annotation_column]], 
    dims = 1:dims
)

integrated_obj$transfered_labels <- predicted_labels$predicted.id
integrated_obj$transfered_label_score <- predicted_labels$prediction.score.max

# --- Assign confident labels ---
integrated_obj$transfered_labels_confident <- ifelse(
    integrated_obj$transfered_label_score >= prediction_score_threshold,
    integrated_obj$transfered_labels,
    "Uncertain"
)

# Factor levels: all observed labels + "Uncertain"
all_labels <- unique(integrated_obj$transfered_labels)
integrated_obj$transfered_labels_confident <- factor(
    integrated_obj$transfered_labels_confident,
    levels = c(all_labels, "Uncertain")
)

# --- DimPlot (raw labels) ---
p1 <- DimPlot(
    integrated_obj,
    group.by = "transfered_labels",
    label = FALSE,
    cols = custom_palette
) + ggtitle("Transferred Labels (Raw)") +
    theme(
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.text = element_text(size = 10)
    )

# --- FeaturePlot for prediction score ---
p2 <- FeaturePlot(
    integrated_obj,
    features = "transfered_label_score"
) + ggtitle("Prediction Score") +
    theme(
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.text = element_text(size = 10)
    )

# --- Violin plot by raw labels ---
p3 <- VlnPlot(
    integrated_obj,
    features = "transfered_label_score",
    group.by = "transfered_labels",
    cols = custom_palette
) + ggtitle("Prediction Score by Label") +
    theme(
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.text.x = element_text(angle = 45, hjust = 1)
    )

# --- DimPlot for confident labels ---
p4 <- DimPlot(
    integrated_obj,
    group.by = "transfered_labels_confident",
    label = FALSE,
    cols = custom_palette
) + ggtitle("Confident Subtype Annotations") +
    theme(
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.text = element_text(size = 10)
    )

# --- Save plots ---
ggsave(label_plot_output, p1, width = umap_width, height = umap_height)
ggsave(score_plot_output, p2, width = umap_width, height = umap_height)
ggsave(violin_plot_output, p3, width = umap_width, height = umap_height)
ggsave(confident_plot_output, p4, width = umap_width, height = umap_height)


# Get all confident labels except "Uncertain"
all_labels <- setdiff(unique(integrated_obj$transfered_labels_confident), "Uncertain")

# --- Folder for individual UMAPs ---
output_umap_folder <- here("output/Individual_UMAPs")
if (!dir.exists(output_umap_folder)) {
  dir.create(output_umap_folder)
}


all_labels <- setdiff(unique(integrated_obj$transfered_labels_confident), "Uncertain")

# Loop through each label and save an individual UMAP to output/
for (lab in all_labels) {
  plot_file <- here("output", paste0("UMAP_", lab, ".pdf"))
  
  p <- DimPlot(
    integrated_obj,
    group.by = "transfered_labels_confident",
    cells.highlight = WhichCells(integrated_obj, expression = transfered_labels_confident == lab),
    cols.highlight = custom_palette[lab],
    cols = "lightgrey"
  ) +
    ggtitle(paste("UMAP for", lab)) +
    theme(
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10)
    )
  
  ggsave(plot_file, p, width = 8, height = 6)
}


# --- Save labeled Seurat object ---
saveRDS(integrated_obj, labeled_seurat_obj_output)

```

```{r}
library(dplyr)
library(ggplot2)
library(here)

# Prepare data
plot_data <- integrated_obj@meta.data %>%
  dplyr::select(condition, transfered_labels_confident) %>%
  filter(transfered_labels_confident != "Uncertain") %>%
  group_by(condition, transfered_labels_confident) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  group_by(condition) %>%
  mutate(
    Total_Count = sum(Count),
    Proportion = Count / Total_Count,
    Percentage = Proportion * 100
  ) %>%
  ungroup()


# Reorder subtypes within each condition by proportion (largest at bottom)
plot_data <- plot_data %>%
  group_by(condition) %>%
  arrange(Percentage) %>%  # smallest first -> biggest at bottom
  mutate(
    transfered_labels_confident =
      factor(transfered_labels_confident,
             levels = unique(transfered_labels_confident))
  ) %>%
  ungroup()


# Distinct color palette
custom_palette <- c(
    "AC-like"     = "#1b9e77",  # dark teal
    "MES-like"    = "#d95f02",  # burnt orange
    "Microglia"   = "#7570b3",  # purple
    "OC-like"     = "#e7298a",  # pink
    "OPC-like-1"  = "#66a61e",  # green
    "OPC-like-2"  = "#e6ab02",  # yellow-orange
    "OPC-like-3"  = "#a6761d"   # brown
)

# --- Reorder conditions for plotting ---
plot_data$condition <- factor(
  plot_data$condition,
  levels = c("NS","BP_Control", "BP_Cues")  
)

# Plot
p_dist <- ggplot(
  plot_data,
  aes(
    x = condition,
    y = Percentage,
    fill = transfered_labels_confident,
    group = interaction(condition, transfered_labels_confident),  # <- add
    order = -Percentage                                          # <- add
  )
) +
  geom_bar(stat = "identity", position = "stack", color = "black", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.1f%%", Percentage)),
            position = position_stack(vjust = 0.5), size = 4, color = "white", fontface = "bold") +
  scale_fill_manual(values = custom_palette) +
  labs(title = "Distribution of Confident Subtypes Across Conditions",
       x = "Condition", y = "Proportion (%)", fill = "Subtype") +
  theme_pubr() + theme(legend.position = "right")

# Save to output/
ggsave(here("output/stacked_barplot_distribution.pdf"), p_dist, width = 8, height = 6)


```

```{r}
composition_table <- plot_data %>%
  dplyr::select(condition, transfered_labels_confident, Percentage) %>%
  tidyr::pivot_wider(names_from = transfered_labels_confident,
                     values_from = Percentage,
                     values_fill = 0) %>%
  left_join(
    plot_data %>%
      distinct(condition, Total_Count),
    by = "condition"
  ) %>%
  arrange(condition)

composition_table

write.csv(composition_table, "output/Composition_table_percentages.csv", row.names = FALSE)

```

##Cell Cycle Scoring

```{r}
integrated_obj <- CellCycleScoring(
  integrated_obj,
  s.features   = cc.genes.updated.2019$s.genes,
  g2m.features = cc.genes.updated.2019$g2m.genes,
  set.ident    = FALSE
)

phase_dim_plot <- DimPlot(integrated_obj, group.by = "Phase") +
  ggtitle("Cell cycle phase across all cells") +
  scale_color_manual(values = c(
    G1  = "#999999",
    S   = "#56B4E9",
    G2M = "#E69F00"
  ))

FeaturePlot(integrated_obj, features = c("S.Score", "G2M.Score"))

# Calculate phase proportions per condition
phase_counts <- prop.table(table(integrated_obj$Phase, integrated_obj$condition), 2) %>%
  as.data.frame() %>%
  dplyr::rename(Phase = Var1, Condition = Var2, Proportion = Freq) %>%
  mutate(
    Condition = factor(Condition, levels = c("NS", "BP_Control", "BP_Cueswha")),
    label = sprintf("%.1f%%", Proportion * 100)   # format labels
  )

# Barplot with percentage labels inside bars
phase_barplot <- ggplot(phase_counts, aes(x = Condition, y = Proportion, fill = Phase)) +
  geom_bar(stat = "identity", position = "fill", color = "black") +
  geom_text(aes(label = label),
            position = position_stack(vjust = 0.5),  # centers labels within stacks
            color = "white", size = 4, fontface = "bold") +
  scale_fill_manual(values = c(G1="#999999", S="#56B4E9", G2M="#E69F00")) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(
    title = "Cell-cycle composition across conditions",
    x = NULL, y = "Fraction of cells", fill = "Phase"
  ) +
  theme_pubr() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 11),
    legend.position = "right"
  )

ggsave(phase_dim_plot, filename = here("output/cell_cycle_phase_umap.pdf"), width = 8, height = 6)
ggsave(phase_barplot, filename = here("output/cell_cycle_phase_barplot.pdf"), width = 8, height = 6)
```

```{r}
meta <- integrated_obj@meta.data
meta$cycling_group <- ifelse(meta$Phase %in% c("S","G2M"), "Cycling", "Non-Cycling")

DefaultAssay(integrated_obj) <- "RNA"
state_list <- list(
  MES1 = MES1_genes,
  MES2 = MES2_genes,
  AC   = AC_genes,
  OPC  = OPC_genes,
  NPC1 = NPC1_genes,
  NPC2 = NPC2_genes
)

integrated_obj <- AddModuleScore(integrated_obj, features = state_list, name = "state_")

```

```{r}
meta <- integrated_obj@meta.data %>%
  mutate(
    state   = transfered_labels_confident,
    cycling = Phase %in% c("S", "G2M")
  ) %>%
  filter(state != "Uncertain")

by_state <- meta %>%
  group_by(state, condition) %>%
  summarise(
    n         = n(),
    n_cycl    = sum(cycling),
    frac_cycl = n_cycl / n,
    .groups   = "drop"
  )

by_state$condition <- factor(by_state$condition,
                             levels = c("NS", "BP_Control", "BP_Cues"))

# >>> set your desired order here <<<
state_order <- c("MES-like",
                 "OPC-like-1",
                 "OPC-like-2",
                 "OPC-like-3",
                 "AC-like",
                 "OC-like")
by_state$state <- factor(by_state$state, levels = state_order)

cycling_fraction_by_state <- ggplot(by_state, aes(state, frac_cycl, fill = condition)) +
  geom_col(position = position_dodge(width = 0.75), color = "black", width = 0.7) +
  geom_text(aes(label = scales::percent(frac_cycl, accuracy = 0.1)),
            position = position_dodge(width = 0.75), vjust = -0.3, size = 3) +
  scale_y_continuous(labels = scales::percent_format(), limits = c(0, 1)) +
  scale_fill_manual(values = c(NS = "#808080",
                               BP_Control = "#0072B2",
                               BP_Cues = "#D55E00")) +
  labs(x = NULL, y = "% cycling (S+G2M)", fill = "Condition",
       title = "Cycling fraction within each predicted state") +
  theme_pubr() +
  theme(axis.text.x = element_text(angle = 40, hjust = 1))

ggsave(cycling_fraction_by_state,
       filename = here("output/cycling_fraction_by_state.pdf"),
       width = 8, height = 6)

```


```{r}
suppressPackageStartupMessages({
  library(Seurat); library(dplyr); library(readxl); library(here); library(ggplot2); library(tidyr)
})

# --- Load module table ---
modules_scores <- read_xlsx(here("data/Filbin_GSE184357/module_scores.xlsx"), skip = 3)

wanted_modules <- c("MES1","MES2","AC","OPC","NPC1","NPC2")
modules_scores <- modules_scores %>% dplyr::select(any_of(wanted_modules))

# --- Build vectors per module, keep only genes present ---
genes_in_obj <- rownames(integrated_obj)
module_list <- lapply(modules_scores, function(col) {
  intersect(unique(na.omit(as.character(col))), genes_in_obj)
})
names(module_list) <- colnames(modules_scores)

# Drop tiny sets and show a quick QC
module_list_present <- module_list[sapply(module_list, length) >= 5]
stopifnot(length(module_list_present) > 0)
cat("Genes per module (in object):\n")
print(sapply(module_list_present, length))

# (Optional) stash for reproducibility
integrated_obj@misc$filbin_gene_sets <- module_list_present

# --- Remove ONLY previous score columns to avoid clutter ---
score_name_regex <- paste0("^(", paste(names(module_list_present), collapse="|"), ")(\\d+)?$")
keep_cols <- setdiff(colnames(integrated_obj@meta.data),
                     grep(score_name_regex, colnames(integrated_obj@meta.data), value = TRUE))
integrated_obj@meta.data <- integrated_obj@meta.data[, keep_cols, drop = FALSE]

# --- Score modules (explicit assay + seed + ctrl) ---
DefaultAssay(integrated_obj) <- "RNA"
set.seed(123)  # reproducible background selection
for (m in names(module_list_present)) {
  integrated_obj <- AddModuleScore(
    integrated_obj,
    features = list(module_list_present[[m]]),
    name = m,                  # produces m1
    nbin = 24,                 # default bins
    ctrl = 100,                # default control genes per bin; explicit = reproducible
    assay = "RNA",
    seed = TRUE
  )
  old <- paste0(m, "1")
  if (old %in% colnames(integrated_obj@meta.data)) {
    colnames(integrated_obj@meta.data)[match(old, colnames(integrated_obj@meta.data))] <- m
  }
}

# --- Violin data ---
meta <- integrated_obj@meta.data
score_cols <- intersect(names(module_list_present), colnames(meta))
stopifnot(length(score_cols) > 0)

# (Optional) consistent condition order
# integrated_obj$condition <- factor(integrated_obj$condition, levels = c("NS","BP_Control","BP_Cues"))

plot_df <- meta %>%
  dplyr::select(condition, dplyr::all_of(score_cols)) %>%
  tidyr::pivot_longer(cols = dplyr::all_of(score_cols),
                      names_to = "module", values_to = "score")

# --- Violin plot (raw module scores) ---
p_violin <- ggplot(plot_df, aes(x = condition, y = score, fill = condition)) +
  geom_violin(scale = "width", trim = TRUE, linewidth = 0.25) +
  stat_summary(fun = median, geom = "point", size = 0.9, color = "black") +
  facet_wrap(~ module, ncol = 3, scales = "free_y") +
  guides(fill = "none") +
  labs(x = NULL, y = "Raw module score per cell",
       title = "Lineage/state program activity across conditions (raw scores)") +
  theme_minimal(base_size = 11) +
  theme(panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 30, hjust = 1))

ggsave(here("output/violin_lineage_modules_by_condition_raw.pdf"),
       p_violin, width = 9, height = 7, units = "in")


# Ensure it's present
integrated_obj$cycling_group <- ifelse(integrated_obj$Phase %in% c("S","G2M"), "Cycling", "Non-Cycling")
plot_df2 <- integrated_obj@meta.data |>
  dplyr::select(condition, cycling_group, dplyr::all_of(score_cols)) |>
  tidyr::pivot_longer(dplyr::all_of(score_cols), names_to="module", values_to="score")

ggplot(plot_df2, aes(condition, score, fill = cycling_group)) +
  geom_violin(scale="width", trim=TRUE, linewidth=0.25, position="identity", alpha=0.6) +
  stat_summary(fun=median, geom="point", size=0.8, color="black", position=position_dodge(width=0.9)) +
  facet_wrap(~ module, ncol=3, scales="free_y") + labs(x=NULL, y="Score")

```


## Do next comparison of clusters between conditions
## Look at overlap between clusters and different labels (Heatmap of proprotions)
```{r}
Idents(integrated_obj) <- "condition"
deg_all <- FindAllMarkers(
  integrated_obj,
  only.pos = FALSE,
  logfc.threshold = 0.25,
  min.pct = 0.1
)

```

```{r}
# Use old.ident directly as the condition label
integrated_obj[["condition"]] <- data.frame(
  condition = as.character(integrated_obj@meta.data$old.ident),
  row.names = Cells(integrated_obj)
)

# Check counts
table(integrated_obj$condition, useNA = "ifany")

# Then proceed to pseudobulk aggregation
state_col <- "transfered_labels_confident"

agg_sc <- AggregateExpression(
  integrated_obj,
  group.by = c(state_col, "condition"),
  assays = "RNA",
  slot = "data",
  return.seurat = TRUE
)

state_col <- "transfered_labels_confident"
conds <- levels(factor(integrated_obj$condition))
pairs <- combn(conds, 2, simplify = FALSE)

# Make readable pseudobulk names like "AC-like_No_Matrix"
colnames(agg_sc) <- paste(agg_sc@meta.data[[state_col]], agg_sc@meta.data$condition, sep = "_")
pb_name <- function(st, cond) paste(st, cond, sep = "_")

all_states <- sort(unique(integrated_obj@meta.data[[state_col]]))
dir.create("output/pseudobulk_scatter", recursive = TRUE, showWarnings = FALSE)

for (st in all_states) {
  have <- sapply(conds, \(cc) pb_name(st, cc) %in% colnames(agg_sc))
  if (!all(have)) next
  panels <- map(pairs, \(p) {
    a <- pb_name(st, p[1]); b <- pb_name(st, p[2])
    CellScatter(agg_sc, a, b) + ggtitle(paste0(st, ": ", p[2], " vs ", p[1]))
  })
  ggsave(file.path("output/pseudobulk_scatter", paste0("CellScatter_", st, ".pdf")),
         cowplot::plot_grid(plotlist = panels, nrow = 1), width = 5*length(pairs), height = 5)
}
```

```{r}
agg_cond <- AggregateExpression(
  integrated_obj,
  group.by = "condition",
  assays = "RNA",
  slot   = "data",          # log-normalized means
  return.seurat = TRUE
)
print(agg_cond@meta.data$condition)
mat <- as.matrix(GetAssayData(agg_cond, slot = "data"))   # genes x conditions

# PCA
pca <- prcomp(t(mat), scale. = TRUE)
df  <- data.frame(pca$x, condition = agg_cond@meta.data$condition)
ggplot(df, aes(PC1, PC2, color = condition)) +
  geom_point(size = 5) + theme_cowplot() +
  labs(title = "Pseudobulk PCA (global): conditions")
ggsave("output/Global_PCA_conditions.pdf", width = 6, height = 5)

# Correlation between condition profiles
pheatmap(cor(mat), main = "Global pseudobulk correlation (conditions)",
         filename = "output/Global_correlation_conditions.pdf")
```


```{r}
state_col <- "transfered_labels_confident"

 ---- Input object & identities ----
Idents(integrated_obj) <- "condition"
conds <- levels(factor(integrated_obj$condition))
stopifnot(length(conds) >= 2)

# ---- 1) Pseudobulk per condition (log-normalized means) ----
agg_cond <- AggregateExpression(
  integrated_obj,
  group.by = "condition",
  assays = "RNA",
  slot   = "data",
  return.seurat = TRUE
)
dir.create("output", showWarnings = FALSE)
message("Conditions: ", paste(agg_cond@meta.data$condition, collapse = ", "))

# Matrix genes x conditions
mat <- as.matrix(GetAssayData(agg_cond, slot = "data"))

# ---- 2) PCA on pseudobulk ----
pca <- prcomp(t(mat), scale. = TRUE)
df  <- data.frame(pca$x, condition = agg_cond@meta.data$condition)
p_pca <- ggplot(df, aes(PC1, PC2, color = condition)) +
  geom_point(size = 5) +
  theme_cowplot() +
  labs(title = "Pseudobulk PCA (global): conditions")
ggsave("output/Global_PCA_conditions.pdf", p_pca, width = 6, height = 5, useDingbats = FALSE)

# ---- 3) Correlations across conditions (matrices + heatmaps + tidy pairwise) ----
cor_pear <- cor(mat, method = "pearson", use = "pairwise.complete.obs")
cor_spea <- cor(mat, method = "spearman", use = "pairwise.complete.obs")
write.csv(cor_pear, "output/Global_correlation_Pearson_conditions.csv")
write.csv(cor_spea, "output/Global_correlation_Spearman_conditions.csv")

pheatmap(cor_pear,
  main = "Global pseudobulk correlation (conditions) — Pearson",
  filename = "output/Global_correlation_Pearson_conditions.pdf"
)
pheatmap(cor_spea,
  main = "Global pseudobulk correlation (conditions) — Spearman",
  filename = "output/Global_correlation_Spearman_conditions.pdf"
)

pairs_tab <- do.call(rbind, combn(colnames(mat), 2, FUN = function(pp) {
  x <- mat[, pp[1]]; y <- mat[, pp[2]]
  ct_p <- suppressWarnings(cor.test(x, y, method = "pearson"))
  ct_s <- suppressWarnings(cor.test(x, y, method = "spearman"))
  data.frame(
    cond1 = pp[1], cond2 = pp[2],
    n_genes = sum(complete.cases(x, y)),
    pearson_r  = unname(ct_p$estimate), pearson_p  = ct_p$p.value,
    spearman_r = unname(ct_s$estimate), spearman_p = ct_s$p.value,
    stringsAsFactors = FALSE
  )
}, simplify = FALSE))
write.csv(pairs_tab, "output/Global_pairwise_correlations.csv", row.names = FALSE)

# ---- 4) Plot function: scatter per pair (no line, red topN, thin label segments) ----
plot_scatter_pair_builtin <- function(
  obj, cond1, cond2,
  topN = 10,
  rank_metric = c("abs_logFC", "logFC"),
  min_mean = 0,
  show_corr = TRUE,
  corr_method = c("pearson","spearman"),
  label_top = FALSE,
  pt.size = 0.2,
  pt.alpha = 0.5,
  top_pt.size = 0.8,
  top_pt.alpha = 0.95,
  top_pt.col = "firebrick",
  line_size_top = 0.2,
  seed = 123
) {
  rank_metric <- match.arg(rank_metric)
  corr_method <- match.arg(corr_method)
  set.seed(seed)

  mat <- as.matrix(GetAssayData(obj, slot = "data"))
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    x = mat[, cond1],
    y = mat[, cond2],
    gene = rownames(mat),
    mean_xy = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_xy >= min_mean, , drop = FALSE]

  df$delta <- df$y - df$x
  score <- if (rank_metric == "abs_logFC") abs(df$delta) else df$delta
  ord <- order(score, decreasing = TRUE, na.last = NA)
  top_genes <- df$gene[head(ord, topN)]

  p <- ggplot(df, aes(x = x, y = y)) +
    geom_point(size = pt.size, alpha = pt.alpha, color = "grey40") +
    geom_point(
      data = subset(df, gene %in% top_genes),
      aes(x = x, y = y),
      color = top_pt.col, size = top_pt.size, alpha = top_pt.alpha
    ) +
    xlab(paste0(cond1, " (log expr)")) +
    ylab(paste0(cond2, " (log expr)")) +
    ggtitle(paste0(cond2, " vs ", cond1)) +
    theme_cowplot() +
    theme(aspect.ratio = 1)

  if (show_corr) {
    ct <- suppressWarnings(cor.test(df$x, df$y, method = corr_method))
    lab <- sprintf("%s r = %.3f (p = %.2g)",
                   tools::toTitleCase(corr_method), ct$estimate, ct$p.value)
    p <- p + annotate("text", x = -Inf, y = Inf, hjust = -0.05, vjust = 1.3, label = lab)
  }
  if (label_top) {
    p <- p + ggrepel::geom_text_repel(
      data = subset(df, gene %in% top_genes),
      aes(label = gene),
      color = top_pt.col, size = 3, force = 2,
      segment.size = line_size_top, box.padding = 0.3,
      point.padding = 0.1, max.overlaps = Inf
    )
  }
  p
}

# ---- 5) CSV writer for most-different genes per pair ----
write_pair_diff_csv <- function(
  obj, cond1, cond2,
  out_dir   = "output/global_scatter",
  topK      = 100,
  min_mean  = 0,
  rank_by   = c("abs_lnFC","lnFC"),
  write_full = TRUE
) {
  rank_by <- match.arg(rank_by)
  mat <- as.matrix(GetAssayData(obj, slot = "data"))
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    gene     = rownames(mat),
    x_log    = mat[, cond1],
    y_log    = mat[, cond2],
    mean_log = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_log >= min_mean, , drop = FALSE]

  df$lnFC      <- df$y_log - df$x_log
  df$abs_lnFC  <- abs(df$lnFC)
  df$log2FC    <- df$lnFC / log(2)
  df$FC        <- exp(df$lnFC)
  df$direction <- ifelse(df$lnFC > 0, paste0("up in ", cond2),
                         ifelse(df$lnFC < 0, paste0("up in ", cond1), "tie"))
  ord_col <- if (rank_by == "abs_lnFC") "abs_lnFC" else "lnFC"
  df <- df[order(df[[ord_col]], decreasing = TRUE), ]
  df$rank <- seq_len(nrow(df))
  df <- df[, c("rank","gene","x_log","y_log","mean_log","lnFC","abs_lnFC","log2FC","FC","direction")]

  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  short_name <- paste0("TOP", topK, "_", cond2, "_vs_", cond1, ".csv")
  full_name  <- paste0("ALL_", cond2, "_vs_", cond1, ".csv")
  write.csv(head(df, topK), file.path(out_dir, short_name), row.names = FALSE)
  if (write_full) write.csv(df, file.path(out_dir, full_name), row.names = FALSE)
  invisible(df)
}

# ---- 6) Generate all pairwise plots + CSVs + a combined table ----
dir.create("output/global_scatter", recursive = TRUE, showWarnings = FALSE)
pairs <- combn(colnames(agg_cond), 2, simplify = FALSE)

all_pairs_table <- lapply(pairs, function(pp) {
  cond1 <- pp[1]; cond2 <- pp[2]

  # Plot
  g <- plot_scatter_pair_builtin(
    obj = agg_cond, cond1 = cond1, cond2 = cond2,
    topN = 10, rank_metric = "abs_logFC",
    min_mean = 0.1, show_corr = TRUE, corr_method = "pearson",
    label_top = FALSE
  )
  gfile <- file.path("output/global_scatter",
                     paste0("CellScatter_GLOBAL_", cond2, "_vs_", cond1, ".pdf"))
  ggsave(gfile, g, width = 5, height = 5, useDingbats = FALSE)

  # CSVs
  df_pair <- write_pair_diff_csv(
    obj = agg_cond, cond1 = cond1, cond2 = cond2,
    out_dir = "output/global_scatter",
    topK = 100, min_mean = 0.1, rank_by = "abs_lnFC", write_full = TRUE
  )
  # add contrast column for combined export
  df_pair$contrast <- paste0(cond2, "_vs_", cond1)
  df_pair
})

combined_df <- do.call(rbind, all_pairs_table)
# Reorder columns for readability
combined_df <- combined_df[, c("contrast","rank","gene","x_log","y_log","mean_log",
                               "lnFC","abs_lnFC","log2FC","FC","direction")]
write.csv(combined_df, "output/global_scatter/COMBINED_all_pairs_diffs.csv", row.names = FALSE)

message("Done. Outputs in ./output and ./output/global_scatter")

```


```{r}
# --- helper to compute & write "most different genes" tables ---
write_pair_diff_csv <- function(
  obj, cond1, cond2,
  out_dir   = "output/global_scatter",
  topK      = 100,                 # how many to export in the top file
  min_mean  = 0,                   # filter tiny/noisy genes by mean log expr
  rank_by   = c("abs_lnFC","lnFC"),# ranking metric
  write_full = TRUE                # also write the full (unfiltered) table
) {
  rank_by <- match.arg(rank_by)

  mat <- as.matrix(GetAssayData(obj, slot = "data"))  # log-normalized (ln scale)
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    gene   = rownames(mat),
    x_log  = mat[, cond1],
    y_log  = mat[, cond2],
    mean_log = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_log >= min_mean, , drop = FALSE]

  # Differences on log scale
  df$lnFC     <- df$y_log - df$x_log                   # natural log fold-change
  df$abs_lnFC <- abs(df$lnFC)
  df$log2FC   <- df$lnFC / log(2)                      # convert to log2
  df$FC       <- exp(df$lnFC)                          # linear fold-change
  df$direction <- ifelse(df$lnFC > 0, paste0("up in ", cond2),
                         ifelse(df$lnFC < 0, paste0("up in ", cond1), "tie"))

  # order & rank
  ord_col <- if (rank_by == "abs_lnFC") "abs_lnFC" else "lnFC"
  df <- df[order(df[[ord_col]], decreasing = TRUE), ]
  df$rank <- seq_len(nrow(df))

  # nice column order
  df <- df[, c("rank","gene",
               "x_log","y_log","mean_log",
               "lnFC","abs_lnFC","log2FC","FC","direction")]

  # write CSVs
  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  short_name <- paste0("TOP", topK, "_", cond2, "_vs_", cond1, ".csv")
  full_name  <- paste0("ALL_", cond2, "_vs_", cond1, ".csv")
  utils::write.csv(head(df, topK),
                   file = file.path(out_dir, short_name), row.names = FALSE)
  if (write_full) {
    utils::write.csv(df, file = file.path(out_dir, full_name), row.names = FALSE)
  }
  invisible(df)
}
```

```{r}
# ---- Setup ----
suppressPackageStartupMessages({
  library(Seurat)
  library(ggplot2)
  library(ggrepel)
  library(cowplot)
  library(pheatmap)
})
theme_set(theme_cowplot())
set.seed(123)

# ---- Input object & identities ----
Idents(integrated_obj) <- "condition"
conds <- levels(factor(integrated_obj$condition))
stopifnot(length(conds) >= 2)

# ---- 1) Pseudobulk per condition ----
agg_cond <- AggregateExpression(
  integrated_obj,
  group.by = "condition",
  assays = "RNA",
  slot   = "data",
  return.seurat = TRUE
)
dir.create("output", showWarnings = FALSE)
message("Conditions: ", paste(agg_cond@meta.data$condition, collapse = ", "))

mat <- as.matrix(GetAssayData(agg_cond, slot = "data"))

# ---- 2) PCA ----
pca <- prcomp(t(mat), scale. = TRUE)
df  <- data.frame(pca$x, condition = agg_cond@meta.data$condition)
ggplot(df, aes(PC1, PC2, color = condition)) +
  geom_point(size = 5) +
  theme_cowplot() +
  labs(title = "Pseudobulk PCA (global): conditions")
ggsave("output/Global_PCA_conditions.pdf", width = 6, height = 5, useDingbats = FALSE)

# ---- 3) Correlation matrices and heatmaps ----
cor_pear <- cor(mat, method = "pearson", use = "pairwise.complete.obs")
cor_spea <- cor(mat, method = "spearman", use = "pairwise.complete.obs")

write.csv(cor_pear, "output/Global_correlation_Pearson_conditions.csv")
write.csv(cor_spea, "output/Global_correlation_Spearman_conditions.csv")

pheatmap(cor_pear, main = "Global pseudobulk correlation — Pearson",
         filename = "output/Global_correlation_Pearson_conditions.pdf")
pheatmap(cor_spea, main = "Global pseudobulk correlation — Spearman",
         filename = "output/Global_correlation_Spearman_conditions.pdf")

pairs_tab <- do.call(rbind, combn(colnames(mat), 2, FUN = function(pp) {
  x <- mat[, pp[1]]; y <- mat[, pp[2]]
  ct_p <- suppressWarnings(cor.test(x, y, method = "pearson"))
  ct_s <- suppressWarnings(cor.test(x, y, method = "spearman"))
  data.frame(
    cond1 = pp[1], cond2 = pp[2],
    n_genes = sum(complete.cases(x, y)),
    pearson_r = unname(ct_p$estimate),
    pearson_p = ct_p$p.value,
    spearman_r = unname(ct_s$estimate),
    spearman_p = ct_s$p.value,
    stringsAsFactors = FALSE
  )
}, simplify = FALSE))
write.csv(pairs_tab, "output/Global_pairwise_correlations.csv", row.names = FALSE)
print(pairs_tab)

# ---- Helper: remove 45° line from CellScatter ----
.rm_abline <- function(p) {
  keep <- vapply(p$layers, function(L) !inherits(L$geom, "GeomAbline"), logical(1))
  p$layers <- p$layers[keep]
  p
}

# ---- 4) Built-in style scatter plot with LabelPoints ----
plot_scatter_pair_builtin <- function(
  obj, cond1, cond2,
  topN = 10,
  rank_metric = c("abs_logFC", "logFC"),
  min_mean = 0,
  show_corr = TRUE,
  corr_method = c("pearson","spearman"),
  label_top = TRUE,
  pt.size = 0.2,
  pt.alpha = 0.5,
  top_pt.size = 0.8,
  top_pt.alpha = 0.95,
  top_pt.col = "firebrick",
  line_size_top = 0.2,
  seed = 123
) {
  rank_metric <- match.arg(rank_metric)
  corr_method <- match.arg(corr_method)
  set.seed(seed)

  mat <- as.matrix(GetAssayData(obj, slot = "data"))
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    x = mat[, cond1],
    y = mat[, cond2],
    gene = rownames(mat),
    mean_xy = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_xy >= min_mean, , drop = FALSE]

  df$delta <- df$y - df$x
  score <- if (rank_metric == "abs_logFC") abs(df$delta) else df$delta
  ord <- order(score, decreasing = TRUE, na.last = NA)
  top_genes <- df$gene[head(ord, topN)]

  # Base plot with CellScatter and top genes highlighted
  p <- CellScatter(obj, cond1, cond2, highlight = top_genes)
  p <- .rm_abline(p)
  p <- p + ggtitle(paste0(cond2, " vs ", cond1)) +
    xlab(paste0(cond1, " (log expr)")) +
    ylab(paste0(cond2, " (log expr)")) +
    theme_cowplot() + theme(aspect.ratio = 1)

  # Make base dots smaller and more transparent
  if (length(p$layers) >= 1) {
    p$layers[[1]]$aes_params$size  <- pt.size
    p$layers[[1]]$aes_params$alpha <- pt.alpha
  }

  # Overplot red points for top genes
  p <- p + geom_point(
    data = subset(df, gene %in% top_genes),
    aes(x = x, y = y),
    inherit.aes = FALSE,
    size = top_pt.size, alpha = top_pt.alpha, color = top_pt.col
  )

  # Add correlation label
  if (show_corr) {
    ct <- suppressWarnings(cor.test(df$x, df$y, method = corr_method))
    lab <- sprintf("%s r = %.3f (p = %.2g)",
                   tools::toTitleCase(corr_method), ct$estimate, ct$p.value)
    p <- p + annotate("text", x = -Inf, y = Inf, hjust = -0.05, vjust = 1.3, label = lab)
  }

  # Add gene labels with repel
  if (label_top) {
    p <- LabelPoints(plot = p, points = top_genes, repel = TRUE)
    # Make repel lines thinner
    p$layers[[length(p$layers)]]$geom_params$segment.size <- line_size_top
  }

  p
}

# ---- 5) Write per-pair CSVs for top differential genes ----
write_pair_diff_csv <- function(
  obj, cond1, cond2,
  out_dir = "output/global_scatter",
  topK = 100,
  min_mean = 0,
  rank_by = c("abs_lnFC","lnFC"),
  write_full = TRUE
) {
  rank_by <- match.arg(rank_by)
  mat <- as.matrix(GetAssayData(obj, slot = "data"))
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    gene     = rownames(mat),
    x_log    = mat[, cond1],
    y_log    = mat[, cond2],
    mean_log = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_log >= min_mean, , drop = FALSE]

  df$lnFC      <- df$y_log - df$x_log
  df$abs_lnFC  <- abs(df$lnFC)
  df$log2FC    <- df$lnFC / log(2)
  df$FC        <- exp(df$lnFC)
  df$direction <- ifelse(df$lnFC > 0, paste0("up in ", cond2),
                         ifelse(df$lnFC < 0, paste0("up in ", cond1), "tie"))
  ord_col <- if (rank_by == "abs_lnFC") "abs_lnFC" else "lnFC"
  df <- df[order(df[[ord_col]], decreasing = TRUE), ]
  df$rank <- seq_len(nrow(df))
  df <- df[, c("rank","gene","x_log","y_log","mean_log","lnFC","abs_lnFC","log2FC","FC","direction")]

  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  short_name <- paste0("TOP", topK, "_", cond2, "_vs_", cond1, ".csv")
  full_name  <- paste0("ALL_", cond2, "_vs_", cond1, ".csv")
  write.csv(head(df, topK), file.path(out_dir, short_name), row.names = FALSE)
  if (write_full) write.csv(df, file.path(out_dir, full_name), row.names = FALSE)
  invisible(df)
}

# ---- 6) Generate all pairwise plots and CSVs ----
dir.create("output/global_scatter", recursive = TRUE, showWarnings = FALSE)
pairs <- combn(colnames(agg_cond), 2, simplify = FALSE)
all_pairs <- lapply(pairs, function(pp) {
  cond1 <- pp[1]; cond2 <- pp[2]
  g <- plot_scatter_pair_builtin(
    obj = agg_cond, cond1 = cond1, cond2 = cond2,
    topN = 10, rank_metric = "abs_logFC",
    min_mean = 0.1, show_corr = TRUE, corr_method = "pearson", label_top = TRUE
  )
  gfile <- file.path("output/global_scatter",
                     paste0("CellScatter_GLOBAL_", cond2, "_vs_", cond1, ".pdf"))
  ggsave(gfile, g, width = 5, height = 5, useDingbats = FALSE)

  df_pair <- write_pair_diff_csv(
    obj = agg_cond, cond1 = cond1, cond2 = cond2,
    out_dir = "output/global_scatter", topK = 100, min_mean = 0.1,
    rank_by = "abs_lnFC", write_full = TRUE
  )
  df_pair$contrast <- paste0(cond2, "_vs_", cond1)
  df_pair
})

combined_df <- do.call(rbind, all_pairs)
combined_df <- combined_df[, c("contrast","rank","gene","x_log","y_log","mean_log",
                               "lnFC","abs_lnFC","log2FC","FC","direction")]
write.csv(combined_df, "output/global_scatter/COMBINED_all_pairs_diffs.csv", row.names = FALSE)

message("Done. Outputs in ./output and ./output/global_scatter")

```

```{r}
state_col <- "transfered_labels_confident"
states <- unique(integrated_obj@meta.data[[state_col]])
state_cells <- lapply(states, function(st) {
  rownames(integrated_obj@meta.data)[integrated_obj@meta.data[[state_col]] == st]
})
names(state_cells) <- states

# one Seurat object per state
objs_by_state <- setNames(
  lapply(names(state_cells), function(st) subset(integrated_obj, cells = state_cells[[st]])),
  names(state_cells)
)

# quick check: number of cells in each object
sapply(objs_by_state, ncol)


```

```{r}
# 0) Identities = transferred labels (states); plot from RNA
Idents(integrated_obj) <- "transfered_labels_confident"
DefaultAssay(integrated_obj) <- "RNA"

# 1) Find markers per state (one vs all)
all_state_markers <- FindAllMarkers(
  integrated_obj,
  only.pos = TRUE,
  logfc.threshold = 0.25,
  min.pct = 0.1
)

# 2) Top-k per state (set k as you like)
k <- 5
topk_state_markers <- all_state_markers %>%
  group_by(cluster) %>%
  slice_max(order_by = avg_log2FC, n = k, with_ties = FALSE) %>%
  ungroup() %>%
  rename(state = cluster)

# 3) Left→right order of states (keep only those present)
state_order <- c("MES-like","AC-like","OPC-like-1","OPC-like-2","OPC-like-3","OC-like","Microglia")
present_states <- intersect(state_order, levels(Idents(integrated_obj)))
integrated_obj$transfered_labels_confident <- factor(
  integrated_obj$transfered_labels_confident, levels = present_states
)

# 4) Features to plot (exactly the top-k per state, deduped & valid)
features_use <- unlist(lapply(present_states, function(st) {
  topk_state_markers %>% filter(state == st) %>% pull(gene)
}), use.names = FALSE) %>%
  unique() %>%
  intersect(rownames(integrated_obj))
stopifnot(length(features_use) > 0)

# (Optional) Export exactly what will be plotted
dir.create(here("output"), showWarnings = FALSE, recursive = TRUE)
write_csv(
  tibble(state = rep(present_states, each = k)) |>
    left_join(topk_state_markers, by = c("state")) |>
    group_by(state) |>
    slice_head(n = k) |>
    ungroup() |>
    select(state, gene, avg_log2FC, p_val_adj),
  here("output/top_markers_plotted_per_transferred_state.csv")
)

# 5) DotPlot
p_dot <- DotPlot(
  integrated_obj,
  features = features_use,
  group.by = "transfered_labels_confident"
) +
  RotatedAxis() +
  labs(title = paste0("Top ", k, " markers per transferred label")) +
  theme(plot.title = element_text(face = "bold"))

ggsave(
  here("output/DotPlot_top_markers_per_transferred_state.pdf"),
  p_dot, width = 12, height = 6, useDingbats = FALSE
)

```


```{r}
# One-state DE between two conditions
state_col <- "transfered_labels_confident"
st  <- "AC-like"       # <— choose a state
c1  <- "NS"            # <— condition A
c2  <- "BP_Cues"       # <— condition B

obj_st <- subset(integrated_obj, subset = !!as.name(state_col) == st)
Idents(obj_st) <- "condition"

de_st <- FindMarkers(
  obj_st, ident.1 = c2, ident.2 = c1,
  min.pct = 0.1, logfc.threshold = 0.25, test.use = "wilcox"
)

head(de_st[order(-de_st$avg_log2FC), ], 15)

# Add -log10(p) for visual emphasis
de_st$gene <- rownames(de_st)
de_st$neglog10p <- -log10(de_st$p_val_adj + 1e-300)

volcanoggplot(de_st, aes(x = avg_log2FC, y = neglog10p)) +
  geom_point(alpha = 0.6) +
  geom_vline(xintercept = c(-0.25, 0.25), linetype = "dashed", color = "grey50") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey50") +
  theme_minimal() +
  labs(
    title = paste0(st, ": ", c2, " vs ", c1),
    x = "Average log2 fold change",
    y = "-log10 adjusted p-value"
  )

```

```{r}
# --- Helper: pseudobulk mean (log-normalized) per gene for a state × condition ---
pseudobulk_state <- function(seu, state, cond) {
  obj <- subset(seu, subset = transfered_labels_confident == state & condition == cond)
  if (ncol(obj) < 5) stop(paste("Too few cells in", state, cond))
  Matrix::rowMeans(GetAssayData(obj, slot = "data"))
}

# --- Compute effect sizes for one state between two conditions ---
effect_size_table <- function(seu, state, cond1, cond2) {
  m1 <- pseudobulk_state(seu, state, cond1)
  m2 <- pseudobulk_state(seu, state, cond2)
  common <- intersect(names(m1), names(m2))
  m1 <- m1[common]; m2 <- m2[common]
  # effect size: difference on log scale ≈ log2FC
  df <- data.frame(
    gene = common,
    meanA = m1, meanB = m2,
    avg_log2FC = (m2 - m1) / log(2),                 # log2 fold-change
    mean_ab = 0.5 * (m1 + m2),                       # average log-expression
    stringsAsFactors = FALSE
  )
  df[order(-abs(df$avg_log2FC)), ]
}

# --- A) MA plot (effect size only) ---
plot_ma <- function(df, title = "") {
  ggplot(df, aes(x = mean_ab, y = avg_log2FC)) +
    geom_hline(yintercept = 0, color = "grey60") +
    geom_point(alpha = 0.5, size = 0.6) +
    labs(x = "Average log-normalized expression",
         y = "log2 fold change (cond2 vs cond1)",
         title = title) +
    theme_minimal()
}

# --- B) Ranked top-|log2FC| bar chart (effect size only) ---
plot_top_fc <- function(df, topN = 15, title = "") {
  top <- head(df, topN)
  ggplot(top, aes(x = reorder(gene, avg_log2FC), y = avg_log2FC, fill = avg_log2FC > 0)) +
    geom_col() +
    coord_flip() +
    scale_fill_manual(values = c("TRUE"="#1b9e77","FALSE"="#d95f02"), guide = "none") +
    labs(x = NULL, y = "log2 fold change (cond2 vs cond1)", title = title) +
    theme_minimal()
}

# ===== Usage: pick a state & conditions =====
st  <- "MES-like"
c1  <- "BP_Cues"
c2  <- "NS"

es <- effect_size_table(integrated_obj, st, c1, c2)

p_ma  <- plot_ma(es,  paste0(st, "  (", c2, " vs ", c1, ")"))
p_bar <- plot_top_fc(es, topN = 12, title = paste0(st, "  top |log2FC| (", c2, " vs ", c1, ")"))

# Save if you want
ggsave(here::here("output", paste0("MA_", st, "_", c2, "_vs_", c1, ".pdf")),  p_ma,  width = 5, height = 4)
ggsave(here::here("output", paste0("TopFC_", st, "_", c2, "_vs_", c1, ".pdf")), p_bar, width = 5, height = 4)
```


```{r}
library(Seurat)
library(dplyr)
library(here)

states <- c("AC-like","MES-like","OPC-like-1","OPC-like-2")
conds  <- c("NS","BP_Control","BP_Cues")  # from unique(integrated_obj$condition)
outdir <- here("output","de_within_state_all_pairs")
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

safe_name <- function(x) gsub("[^A-Za-z0-9._-]+", "_", x)
summary_rows <- list()

for (st in states) {
  obj_st <- subset(integrated_obj, subset = transfered_labels_confident == st)
  if (ncol(obj_st) < 10) next
  Idents(obj_st) <- "condition"

  pairs <- combn(conds, 2, simplify = FALSE)
  for (pp in pairs) {
    c1 <- pp[1]; c2 <- pp[2]
    if (sum(obj_st$condition == c1) < 10 || sum(obj_st$condition == c2) < 10) next

    # Run DE using all cells
    de_tab <- FindMarkers(
      obj_st, ident.1 = c2, ident.2 = c1,
      test.use = "wilcox", min.pct = 0.10, logfc.threshold = 0.25
    )

    de_tab$gene <- rownames(de_tab)
    de_tab <- de_tab[order(-abs(de_tab$avg_log2FC)), ]

    fname <- paste0("DE_", safe_name(st), "_", safe_name(c2), "_vs_", safe_name(c1), ".csv")
    write.csv(de_tab, file.path(outdir, fname), row.names = FALSE)

    summary_rows[[length(summary_rows)+1]] <- data.frame(
      state = st,
      contrast = paste0(c2, " vs ", c1),
      n_cells_c1 = sum(obj_st$condition == c1),
      n_cells_c2 = sum(obj_st$condition == c2),
      n_genes_up = sum(de_tab$avg_log2FC >  0.25, na.rm = TRUE),
      n_genes_down = sum(de_tab$avg_log2FC < -0.25, na.rm = TRUE)
    )
    message("Done: ", st, " (", c2, " vs ", c1, ")")
  }
}

if (length(summary_rows)) {
  summary_df <- bind_rows(summary_rows)
  write.csv(summary_df, file.path(outdir, "SUMMARY_all_pairs.csv"), row.names = FALSE)
  print(summary_df)
}


```


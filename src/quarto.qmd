---
title: "compare_conditions"
toc: true
format:
  html:
    code-fold: false
    code-tools: true
    self-contained: true
    number-sections: true
    theme: flatly
    lightbox: true
execute: 
  output: false
  error: false
  warning: false
  echo: false
project:
  execute-dir: journal
---

```{r, setup, include=FALSE}
library(knitr)
library(here)
library(Seurat)
library(ggVennDiagram)
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(viridis)
library(patchwork)
library(svglite)
library(glmGamPoi)
library(RColorBrewer)
library(readxl)
library(clusterProfiler)
library(org.Hs.eg.db)
library(cowplot)
library(purrr)
library(cowplot)
library(ggrepel)

opts_knit$set(root.dir = here())
```

```{r}
seurat_neurospheres <- readRDS(here("data/seurat_neurospheres.rds"))
seurat_bioinert <- readRDS(here("data/seurat_bioinert.rds"))
seurat_biofunctional <- readRDS(here("data/seurat_biofunctional.rds"))
```

```{r}
# 1. Create a list of your three Seurat objects
# This is the starting point for anchor-based integration
obj_list <- list(
  seurat_neurospheres,
  seurat_bioinert,
  seurat_biofunctional
)

names(obj_list) <- c("NS", "BP_Control", "BP_Cues")

for (i in 1:length(obj_list)) {
  obj_list[[i]]$condition <- names(obj_list)[i]
}

obj_list <- lapply(X = obj_list, FUN = function(x) {
  SCTransform(x, vst.flavor = "v2", verbose = FALSE, conserve.memory = TRUE) %>%
  RunPCA(npcs = 30, verbose = FALSE)
})

features <- SelectIntegrationFeatures(object.list = obj_list, nfeatures = 2000)
```

```{r}
# 1. Prepare data for SCT integration
obj_list <- PrepSCTIntegration(object.list = obj_list, anchor.features = features)

# 2. Find the integration anchors
anchors <- FindIntegrationAnchors(
  object.list = obj_list,
  normalization.method = "SCT",
  anchor.features = features
)

# 3. Integrate the data into a single object
# The resulting object is named 'integrated_obj' and contains the batch-corrected 'integrated' assay.
integrated_obj <- IntegrateData(anchorset = anchors, normalization.method = "SCT")
```

```{r}
# 1. Set the default assay to 'integrated'
DefaultAssay(integrated_obj) <- "integrated"

# 2. Run PCA, Clustering, and UMAP on the integrated data
integrated_obj <- RunPCA(integrated_obj, npcs = 30, verbose = FALSE)
integrated_obj <- FindNeighbors(integrated_obj, dims = 1:30, verbose = FALSE)
integrated_obj <- FindClusters(integrated_obj, resolution = 0.6, verbose = FALSE)
integrated_obj <- RunUMAP(integrated_obj, dims = 1:30, verbose = FALSE)

# 3. Store cluster IDs for analysis
integrated_obj[["cluster_id"]] <- Idents(object = integrated_obj)
```

```{r}
saveRDS(integrated_obj, file = here("data/processed/integrated_seurat.rds"))
```

```{r}
condition_colors <- c("NS" = "#808080",      
                           "BP_Control" = "#0072B2", 
                           "BP_Cues" = "#D55E00") 
condition_order <- c("NS", "BP_Control", "BP_Cues")

integrated_obj$condition <- factor(integrated_obj$condition, levels = condition_order)

plot_A <- DimPlot(integrated_obj, 
                  reduction = "umap", 
                  group.by = "condition",
                  cols = condition_colors,
                  label = FALSE) + 
  ggtitle("A. Integrated UMAP (Colored by Condition)") +
  theme(plot.title = element_text(face = "bold", size = 14))

plot_B <- DimPlot(integrated_obj, 
                  reduction = "umap", 
                  group.by = "condition",
                  cols = condition_colors, 
                  split.by = "condition",
                  label = FALSE) +
  ggtitle("B. UMAP Split by Condition (Visualizing Structure)") +
  theme(plot.title = element_text(face = "bold", size = 14))




ggsave(plot = plot_A, filename = here("output/umap_by_condition.pdf"), height = 8, width = 10)

ggsave(plot = plot_B, filename = here("output/umap_by_condition_split.pdf"), height = 8, width = 10)
```

```{r}

n_clusters <- length(unique(integrated_obj$seurat_clusters))

base_colors <- c(brewer.pal(n = 12, name = "Set3"), 
                 brewer.pal(n = 12, name = "Paired"))

cluster_colors <- colorRampPalette(base_colors)(n_clusters)

umap_clusters <- DimPlot(integrated_obj, 
                  reduction = "umap", 
                  group.by = "seurat_clusters",
                  cols = cluster_colors,
                  label = TRUE, 
                  repel = TRUE) + 
  ggtitle("Figure 2. Integrated UMAP (Colored by Cluster ID)") +
  theme(plot.title = element_text(face = "bold", size = 14),
        legend.position = "right") 

ggsave(umap_clusters, filename = here("output/umap_by_cluster.pdf"), height = 8, width = 10)

```

```{r}
DefaultAssay(integrated_obj) <- "integrated"

all_cluster_markers <- FindAllMarkers(
  object = integrated_obj, 
  only.pos = TRUE,         
  min.pct = 0.1,           
  logfc.threshold = 0.25,
  assay = "integrated"
)

top3_markers <- all_cluster_markers %>%
  group_by(cluster) %>%
  slice_max(n = 3, order_by = avg_log2FC)

genes_to_plot <- unique(top3_markers$gene)

DefaultAssay(integrated_obj) <- "RNA"

cluster_markers_umap <- DotPlot(integrated_obj, 
                  features = genes_to_plot, 
                  cols = c("lightgrey", "#D55E00"),
                  dot.scale = 8) + 
  RotatedAxis() +
  ggtitle("Figure 3. Top Marker Gene Expression Across Cell Clusters") +
  theme(plot.title = element_text(face = "bold", size = 14),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 10))

ggsave(plot_D, filename = here("output/cluster_markers_umap.pdf"), height = 8, width = 12)

```

```{r}
markers_filtered <- all_cluster_markers %>%
  filter(p_val_adj < 0.05, avg_log2FC > 0.25)

top_markers <- markers_filtered %>%
  group_by(cluster) %>%
  slice_max(order_by = avg_log2FC, n = 50)

# convert gene symbols to Entrez IDs
cluster_list <- split(top_markers$gene, top_markers$cluster)

enrich_results <- lapply(names(cluster_list), function(clust) {
  genes <- cluster_list[[clust]]
  genes_entrez <- bitr(genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
  
  ego <- enrichGO(
    gene         = genes_entrez$ENTREZID,
    OrgDb        = org.Hs.eg.db,
    ont          = "BP",
    readable     = TRUE,
    pAdjustMethod = "BH",
    qvalueCutoff = 0.05
  )
  ego@result$Cluster <- clust
  return(ego@result)
})

# combine into one dataframe
enrich_df <- do.call(rbind, enrich_results)

```

```{r}
enrich_df <- enrich_df %>% filter(!is.na(p.adjust))

# top 3 terms per cluster by smallest adjusted p-value
top_terms <- enrich_df %>%
  group_by(Cluster) %>%
  slice_min(order_by = p.adjust, n = 3, with_ties = FALSE) %>%
  ungroup() %>%
  dplyr::select(Cluster, Description, p.adjust, GeneRatio, Count)

top_terms

```



## Label Transfer

```{r}
# --- File paths ---
integrated_obj_path <- here("data/processed/integrated_seurat.rds")
reference_matrix_path <- here("data/Filbin_GSE184357/counts_fresh_postFilter.txt") 
reference_metadata_path <- here("data/Filbin_GSE184357/metadata_fresh_postFilter.txt") 

reference_seurat_obj_output <- here("output/filbin_reference_seurat_obj.rds")
labeled_seurat_obj_output <- here("output/labeled_integrated_obj.rds") 
label_plot_output <- here("output/label_plot_raw.pdf")
score_plot_output <- here("output/score_plot.pdf")
violin_plot_output <- here("output/violin_plot.pdf")
confident_plot_output <- here("output/confident_plot.pdf")

# --- Parameters ---
dims <- 30
prediction_score_threshold <- 0.5
annotation_column <- "annotation"
filter_values <- c("G2M", "S") 
umap_width <- 12 
umap_height <- 10 

# --- Custom color palette for all labels ---
custom_palette <- c(
    "AC-like"     = "#1b9e77",  # dark teal
    "MES-like"    = "#d95f02",  # burnt orange
    "Microglia"   = "#7570b3",  # purple
    "OC-like"     = "#e7298a",  # pink
    "OPC-like-1"  = "#66a61e",  # green
    "OPC-like-2"  = "#e6ab02",  # yellow-orange
    "OPC-like-3"  = "#a6761d"   # brown
)

# --- Load Seurat object ---
integrated_obj <- readRDS(integrated_obj_path)

# --- Load reference ---
reference_matrix <- read.table(reference_matrix_path, header = TRUE, sep = "\t", row.names = 1)
reference_metadata <- read.table(reference_metadata_path, header = TRUE, sep = "\t", row.names = 1)

reference <- CreateSeuratObject(counts = reference_matrix)
reference <- AddMetaData(reference, metadata = reference_metadata)

# --- Filter reference cells ---
if (length(filter_values) > 0) {
    cells_to_keep_anno <- !(reference@meta.data[[annotation_column]] %in% filter_values)
    reference <- subset(reference, cells = rownames(reference@meta.data)[cells_to_keep_anno])
}

# --- Shared genes ---
shared_genes <- intersect(rownames(reference), rownames(integrated_obj))

# --- SCTransform + PCA ---
reference <- SCTransform(reference, verbose = FALSE)
reference <- RunPCA(reference, verbose = FALSE, features = shared_genes)

# --- Save reference object ---
saveRDS(reference, reference_seurat_obj_output)

# --- Transfer anchors & labels ---
anchors <- FindTransferAnchors(
    reference = reference,
    query = integrated_obj, 
    dims = 1:dims,
    features = shared_genes,
    normalization.method = "SCT"
)

predicted_labels <- TransferData(
    anchorset = anchors,
    refdata = reference@meta.data[[annotation_column]], 
    dims = 1:dims
)

integrated_obj$transfered_labels <- predicted_labels$predicted.id
integrated_obj$transfered_label_score <- predicted_labels$prediction.score.max

# --- Assign confident labels ---
integrated_obj$transfered_labels_confident <- ifelse(
    integrated_obj$transfered_label_score >= prediction_score_threshold,
    integrated_obj$transfered_labels,
    "Uncertain"
)

# Factor levels: all observed labels + "Uncertain"
all_labels <- unique(integrated_obj$transfered_labels)
integrated_obj$transfered_labels_confident <- factor(
    integrated_obj$transfered_labels_confident,
    levels = c(all_labels, "Uncertain")
)

# --- DimPlot (raw labels) ---
p1 <- DimPlot(
    integrated_obj,
    group.by = "transfered_labels",
    label = FALSE,
    cols = custom_palette
) + ggtitle("Transferred Labels (Raw)") +
    theme(
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.text = element_text(size = 10)
    )

# --- FeaturePlot for prediction score ---
p2 <- FeaturePlot(
    integrated_obj,
    features = "transfered_label_score"
) + ggtitle("Prediction Score") +
    theme(
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.text = element_text(size = 10)
    )

# --- Violin plot by raw labels ---
p3 <- VlnPlot(
    integrated_obj,
    features = "transfered_label_score",
    group.by = "transfered_labels",
    cols = custom_palette
) + ggtitle("Prediction Score by Label") +
    theme(
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.text.x = element_text(angle = 45, hjust = 1)
    )

# --- DimPlot for confident labels ---
p4 <- DimPlot(
    integrated_obj,
    group.by = "transfered_labels_confident",
    label = FALSE,
    cols = custom_palette
) + ggtitle("Confident Subtype Annotations") +
    theme(
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.text = element_text(size = 10)
    )

# --- Save plots ---
ggsave(label_plot_output, p1, width = umap_width, height = umap_height)
ggsave(score_plot_output, p2, width = umap_width, height = umap_height)
ggsave(violin_plot_output, p3, width = umap_width, height = umap_height)
ggsave(confident_plot_output, p4, width = umap_width, height = umap_height)


# Get all confident labels except "Uncertain"
all_labels <- setdiff(unique(integrated_obj$transfered_labels_confident), "Uncertain")

# --- Folder for individual UMAPs ---
output_umap_folder <- here("output/Individual_UMAPs")
if (!dir.exists(output_umap_folder)) {
  dir.create(output_umap_folder)
}


all_labels <- setdiff(unique(integrated_obj$transfered_labels_confident), "Uncertain")

# Loop through each label and save an individual UMAP to output/
for (lab in all_labels) {
  plot_file <- here("output", paste0("UMAP_", lab, ".pdf"))
  
  p <- DimPlot(
    integrated_obj,
    group.by = "transfered_labels_confident",
    cells.highlight = WhichCells(integrated_obj, expression = transfered_labels_confident == lab),
    cols.highlight = custom_palette[lab],
    cols = "lightgrey"
  ) +
    ggtitle(paste("UMAP for", lab)) +
    theme(
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10)
    )
  
  ggsave(plot_file, p, width = 8, height = 6)
}


# --- Save labeled Seurat object ---
saveRDS(integrated_obj, labeled_seurat_obj_output)

```

```{r}
library(dplyr)
library(ggplot2)
library(here)

integrated_obj[["condition"]] <- data.frame(
  condition = as.character(integrated_obj@meta.data$old.ident),
  row.names = Cells(integrated_obj)
)
# Prepare data
plot_data <- integrated_obj@meta.data %>%
  dplyr::select(condition, transfered_labels_confident) %>%
  filter(transfered_labels_confident != "Uncertain") %>%
  group_by(condition, transfered_labels_confident) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  group_by(condition) %>%
  mutate(
    Total_Count = sum(Count),
    Proportion = Count / Total_Count,
    Percentage = Proportion * 100
  ) %>%
  ungroup()


# Reorder subtypes within each condition by proportion (largest at bottom)
plot_data <- plot_data %>%
  group_by(condition) %>%
  arrange(Percentage) %>%  # smallest first -> biggest at bottom
  mutate(
    transfered_labels_confident =
      factor(transfered_labels_confident,
             levels = unique(transfered_labels_confident))
  ) %>%
  ungroup()


# Distinct color palette
custom_palette <- c(
    "AC-like"     = "#1b9e77",  # dark teal
    "MES-like"    = "#d95f02",  # burnt orange
    "Microglia"   = "#7570b3",  # purple
    "OC-like"     = "#e7298a",  # pink
    "OPC-like-1"  = "#66a61e",  # green
    "OPC-like-2"  = "#e6ab02",  # yellow-orange
    "OPC-like-3"  = "#a6761d"   # brown
)


# Plot
p_dist <- ggplot(
  plot_data,
  aes(
    x = condition,
    y = Percentage,
    fill = transfered_labels_confident,
    group = interaction(condition, transfered_labels_confident),  # <- add
    order = -Percentage                                          # <- add
  )
) +
  geom_bar(stat = "identity", position = "stack", color = "black", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.1f%%", Percentage)),
            position = position_stack(vjust = 0.5), size = 4, color = "white", fontface = "bold") +
  scale_fill_manual(values = custom_palette) +
  labs(title = "Distribution of Confident Subtypes Across Conditions",
       x = "Condition", y = "Proportion (%)", fill = "Subtype") +
  theme_pubr() + theme(legend.position = "right")

# Save to output/
ggsave(here("output/stacked_barplot_distribution.pdf"), p_dist, width = 8, height = 6)


```

```{r}
composition_table <- plot_data %>%
  dplyr::select(condition, transfered_labels_confident, Percentage) %>%
  tidyr::pivot_wider(names_from = transfered_labels_confident,
                     values_from = Percentage,
                     values_fill = 0) %>%
  left_join(
    plot_data %>%
      distinct(condition, Total_Count),
    by = "condition"
  ) %>%
  arrange(condition)

composition_table

write.csv(composition_table, "output/Composition_table_percentages.csv", row.names = FALSE)

```


```{r}
#--- Load object
#integrated_obj <- readRDS(here("data/processed/Filbin_labeled_integrated_obj.rds"))

#--- Read gene sets (each column = module; entries = gene symbols)
modules_scores <- read_xlsx(here("data/Filbin_GSE184357/module_scores.xlsx"), skip = 3)

#--- Keep only lineage/state modules (no cell-cycle)
wanted_modules <- c("MES1","MES2","AC","OPC","NPC1","NPC2")
modules_scores <- modules_scores %>% dplyr::select(any_of(wanted_modules))

#--- Make list of gene vectors
module_list <- lapply(modules_scores, function(col) na.omit(as.character(col)))
names(module_list) <- colnames(modules_scores)

#--- Keep genes present in object (and drop tiny sets)
module_list_present <- lapply(module_list, function(genes) intersect(genes, rownames(integrated_obj)))
module_list_present <- module_list_present[sapply(module_list_present, length) >= 5]
if (length(module_list_present) == 0) stop("No valid genes found for modules!")

#--- 0) Remove any previous module-score clutter to avoid MES12/AC3 etc.
old_cols <- grep("^(MES|AC|OPC|NPC)", colnames(integrated_obj@meta.data), value = TRUE)
keep_cols <- setdiff(colnames(integrated_obj@meta.data), setdiff(old_cols, "condition"))
integrated_obj@meta.data <- integrated_obj@meta.data[, keep_cols, drop = FALSE]

#--- 1) Add scores one module at a time (independent controls; clean names)
for (m in names(module_list_present)) {
  integrated_obj <- AddModuleScore(
    integrated_obj,
    features = list(module_list_present[[m]]),
    name = m               # produces m1
  )
  old <- paste0(m, "1")
  if (old %in% colnames(integrated_obj@meta.data)) {
    colnames(integrated_obj@meta.data)[match(old, colnames(integrated_obj@meta.data))] <- m
  }
}

#--- 2) Prepare data for violin plotting (RAW scores, no z-score)
meta <- integrated_obj@meta.data
score_cols <- intersect(names(module_list_present), colnames(meta))
if (length(score_cols) == 0) stop("No score columns found after scoring.")

plot_df <- meta %>%
  dplyr::select(condition, dplyr::all_of(score_cols)) %>%
  tidyr::pivot_longer(cols = dplyr::all_of(score_cols),
                      names_to = "module", values_to = "score")

# Optional: fix condition order if you have a preferred one
# plot_df$condition <- factor(plot_df$condition, levels = c("NS","BP_Control","BP_Cues"))

#--- 3) Violin plot (RAW scores). Use free_y since modules have different ranges.
p_violin <- ggplot(plot_df, aes(x = condition, y = score, fill = condition)) +
  geom_violin(scale = "width", trim = TRUE, linewidth = 0.25) +
  stat_summary(fun = median, geom = "point", size = 0.9, color = "black") +
  facet_wrap(~ module, ncol = 3, scales = "free_y") +
  guides(fill = "none") +
  labs(x = NULL, y = "Raw module score per cell",
       title = "Lineage/state program activity across conditions (raw scores)") +
  theme_minimal(base_size = 11) +
  theme(panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 30, hjust = 1))

print(p_violin)

#--- 4) Save sized PDF
ggsave(here("output/violin_lineage_modules_by_condition_raw.pdf"),
       p_violin, width = 9, height = 7, units = "in")
```


## Do next comparison of clusters between conditions
## Look at overlap between clusters and different labels (Heatmap of proprotions)
```{r}
Idents(integrated_obj) <- "condition"
deg_all <- FindAllMarkers(
  integrated_obj,
  only.pos = FALSE,
  logfc.threshold = 0.25,
  min.pct = 0.1
)

```

```{r}
# Use old.ident directly as the condition label
integrated_obj[["condition"]] <- data.frame(
  condition = as.character(integrated_obj@meta.data$old.ident),
  row.names = Cells(integrated_obj)
)

# Check counts
table(integrated_obj$condition, useNA = "ifany")

# Then proceed to pseudobulk aggregation
state_col <- "transfered_labels_confident"

agg_sc <- AggregateExpression(
  integrated_obj,
  group.by = c(state_col, "condition"),
  assays = "RNA",
  slot = "data",
  return.seurat = TRUE
)

state_col <- "transfered_labels_confident"
conds <- levels(factor(integrated_obj$condition))
pairs <- combn(conds, 2, simplify = FALSE)

# Make readable pseudobulk names like "AC-like_No_Matrix"
colnames(agg_sc) <- paste(agg_sc@meta.data[[state_col]], agg_sc@meta.data$condition, sep = "_")
pb_name <- function(st, cond) paste(st, cond, sep = "_")

all_states <- sort(unique(integrated_obj@meta.data[[state_col]]))
dir.create("output/pseudobulk_scatter", recursive = TRUE, showWarnings = FALSE)

for (st in all_states) {
  have <- sapply(conds, \(cc) pb_name(st, cc) %in% colnames(agg_sc))
  if (!all(have)) next
  panels <- map(pairs, \(p) {
    a <- pb_name(st, p[1]); b <- pb_name(st, p[2])
    CellScatter(agg_sc, a, b) + ggtitle(paste0(st, ": ", p[2], " vs ", p[1]))
  })
  ggsave(file.path("output/pseudobulk_scatter", paste0("CellScatter_", st, ".pdf")),
         cowplot::plot_grid(plotlist = panels, nrow = 1), width = 5*length(pairs), height = 5)
}
```

```{r}
agg_cond <- AggregateExpression(
  integrated_obj,
  group.by = "condition",
  assays = "RNA",
  slot   = "data",          # log-normalized means
  return.seurat = TRUE
)
print(agg_cond@meta.data$condition)
mat <- as.matrix(GetAssayData(agg_cond, slot = "data"))   # genes x conditions

# PCA
pca <- prcomp(t(mat), scale. = TRUE)
df  <- data.frame(pca$x, condition = agg_cond@meta.data$condition)
ggplot(df, aes(PC1, PC2, color = condition)) +
  geom_point(size = 5) + theme_cowplot() +
  labs(title = "Pseudobulk PCA (global): conditions")
ggsave("output/Global_PCA_conditions.pdf", width = 6, height = 5)

# Correlation between condition profiles
pheatmap(cor(mat), main = "Global pseudobulk correlation (conditions)",
         filename = "output/Global_correlation_conditions.pdf")
```


```{r}
state_col <- "transfered_labels_confident"

 ---- Input object & identities ----
Idents(integrated_obj) <- "condition"
conds <- levels(factor(integrated_obj$condition))
stopifnot(length(conds) >= 2)

# ---- 1) Pseudobulk per condition (log-normalized means) ----
agg_cond <- AggregateExpression(
  integrated_obj,
  group.by = "condition",
  assays = "RNA",
  slot   = "data",
  return.seurat = TRUE
)
dir.create("output", showWarnings = FALSE)
message("Conditions: ", paste(agg_cond@meta.data$condition, collapse = ", "))

# Matrix genes x conditions
mat <- as.matrix(GetAssayData(agg_cond, slot = "data"))

# ---- 2) PCA on pseudobulk ----
pca <- prcomp(t(mat), scale. = TRUE)
df  <- data.frame(pca$x, condition = agg_cond@meta.data$condition)
p_pca <- ggplot(df, aes(PC1, PC2, color = condition)) +
  geom_point(size = 5) +
  theme_cowplot() +
  labs(title = "Pseudobulk PCA (global): conditions")
ggsave("output/Global_PCA_conditions.pdf", p_pca, width = 6, height = 5, useDingbats = FALSE)

# ---- 3) Correlations across conditions (matrices + heatmaps + tidy pairwise) ----
cor_pear <- cor(mat, method = "pearson", use = "pairwise.complete.obs")
cor_spea <- cor(mat, method = "spearman", use = "pairwise.complete.obs")
write.csv(cor_pear, "output/Global_correlation_Pearson_conditions.csv")
write.csv(cor_spea, "output/Global_correlation_Spearman_conditions.csv")

pheatmap(cor_pear,
  main = "Global pseudobulk correlation (conditions) — Pearson",
  filename = "output/Global_correlation_Pearson_conditions.pdf"
)
pheatmap(cor_spea,
  main = "Global pseudobulk correlation (conditions) — Spearman",
  filename = "output/Global_correlation_Spearman_conditions.pdf"
)

pairs_tab <- do.call(rbind, combn(colnames(mat), 2, FUN = function(pp) {
  x <- mat[, pp[1]]; y <- mat[, pp[2]]
  ct_p <- suppressWarnings(cor.test(x, y, method = "pearson"))
  ct_s <- suppressWarnings(cor.test(x, y, method = "spearman"))
  data.frame(
    cond1 = pp[1], cond2 = pp[2],
    n_genes = sum(complete.cases(x, y)),
    pearson_r  = unname(ct_p$estimate), pearson_p  = ct_p$p.value,
    spearman_r = unname(ct_s$estimate), spearman_p = ct_s$p.value,
    stringsAsFactors = FALSE
  )
}, simplify = FALSE))
write.csv(pairs_tab, "output/Global_pairwise_correlations.csv", row.names = FALSE)

# ---- 4) Plot function: scatter per pair (no line, red topN, thin label segments) ----
plot_scatter_pair_builtin <- function(
  obj, cond1, cond2,
  topN = 10,
  rank_metric = c("abs_logFC", "logFC"),
  min_mean = 0,
  show_corr = TRUE,
  corr_method = c("pearson","spearman"),
  label_top = FALSE,
  pt.size = 0.2,
  pt.alpha = 0.5,
  top_pt.size = 0.8,
  top_pt.alpha = 0.95,
  top_pt.col = "firebrick",
  line_size_top = 0.2,
  seed = 123
) {
  rank_metric <- match.arg(rank_metric)
  corr_method <- match.arg(corr_method)
  set.seed(seed)

  mat <- as.matrix(GetAssayData(obj, slot = "data"))
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    x = mat[, cond1],
    y = mat[, cond2],
    gene = rownames(mat),
    mean_xy = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_xy >= min_mean, , drop = FALSE]

  df$delta <- df$y - df$x
  score <- if (rank_metric == "abs_logFC") abs(df$delta) else df$delta
  ord <- order(score, decreasing = TRUE, na.last = NA)
  top_genes <- df$gene[head(ord, topN)]

  p <- ggplot(df, aes(x = x, y = y)) +
    geom_point(size = pt.size, alpha = pt.alpha, color = "grey40") +
    geom_point(
      data = subset(df, gene %in% top_genes),
      aes(x = x, y = y),
      color = top_pt.col, size = top_pt.size, alpha = top_pt.alpha
    ) +
    xlab(paste0(cond1, " (log expr)")) +
    ylab(paste0(cond2, " (log expr)")) +
    ggtitle(paste0(cond2, " vs ", cond1)) +
    theme_cowplot() +
    theme(aspect.ratio = 1)

  if (show_corr) {
    ct <- suppressWarnings(cor.test(df$x, df$y, method = corr_method))
    lab <- sprintf("%s r = %.3f (p = %.2g)",
                   tools::toTitleCase(corr_method), ct$estimate, ct$p.value)
    p <- p + annotate("text", x = -Inf, y = Inf, hjust = -0.05, vjust = 1.3, label = lab)
  }
  if (label_top) {
    p <- p + ggrepel::geom_text_repel(
      data = subset(df, gene %in% top_genes),
      aes(label = gene),
      color = top_pt.col, size = 3, force = 2,
      segment.size = line_size_top, box.padding = 0.3,
      point.padding = 0.1, max.overlaps = Inf
    )
  }
  p
}

# ---- 5) CSV writer for most-different genes per pair ----
write_pair_diff_csv <- function(
  obj, cond1, cond2,
  out_dir   = "output/global_scatter",
  topK      = 100,
  min_mean  = 0,
  rank_by   = c("abs_lnFC","lnFC"),
  write_full = TRUE
) {
  rank_by <- match.arg(rank_by)
  mat <- as.matrix(GetAssayData(obj, slot = "data"))
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    gene     = rownames(mat),
    x_log    = mat[, cond1],
    y_log    = mat[, cond2],
    mean_log = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_log >= min_mean, , drop = FALSE]

  df$lnFC      <- df$y_log - df$x_log
  df$abs_lnFC  <- abs(df$lnFC)
  df$log2FC    <- df$lnFC / log(2)
  df$FC        <- exp(df$lnFC)
  df$direction <- ifelse(df$lnFC > 0, paste0("up in ", cond2),
                         ifelse(df$lnFC < 0, paste0("up in ", cond1), "tie"))
  ord_col <- if (rank_by == "abs_lnFC") "abs_lnFC" else "lnFC"
  df <- df[order(df[[ord_col]], decreasing = TRUE), ]
  df$rank <- seq_len(nrow(df))
  df <- df[, c("rank","gene","x_log","y_log","mean_log","lnFC","abs_lnFC","log2FC","FC","direction")]

  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  short_name <- paste0("TOP", topK, "_", cond2, "_vs_", cond1, ".csv")
  full_name  <- paste0("ALL_", cond2, "_vs_", cond1, ".csv")
  write.csv(head(df, topK), file.path(out_dir, short_name), row.names = FALSE)
  if (write_full) write.csv(df, file.path(out_dir, full_name), row.names = FALSE)
  invisible(df)
}

# ---- 6) Generate all pairwise plots + CSVs + a combined table ----
dir.create("output/global_scatter", recursive = TRUE, showWarnings = FALSE)
pairs <- combn(colnames(agg_cond), 2, simplify = FALSE)

all_pairs_table <- lapply(pairs, function(pp) {
  cond1 <- pp[1]; cond2 <- pp[2]

  # Plot
  g <- plot_scatter_pair_builtin(
    obj = agg_cond, cond1 = cond1, cond2 = cond2,
    topN = 10, rank_metric = "abs_logFC",
    min_mean = 0.1, show_corr = TRUE, corr_method = "pearson",
    label_top = FALSE
  )
  gfile <- file.path("output/global_scatter",
                     paste0("CellScatter_GLOBAL_", cond2, "_vs_", cond1, ".pdf"))
  ggsave(gfile, g, width = 5, height = 5, useDingbats = FALSE)

  # CSVs
  df_pair <- write_pair_diff_csv(
    obj = agg_cond, cond1 = cond1, cond2 = cond2,
    out_dir = "output/global_scatter",
    topK = 100, min_mean = 0.1, rank_by = "abs_lnFC", write_full = TRUE
  )
  # add contrast column for combined export
  df_pair$contrast <- paste0(cond2, "_vs_", cond1)
  df_pair
})

combined_df <- do.call(rbind, all_pairs_table)
# Reorder columns for readability
combined_df <- combined_df[, c("contrast","rank","gene","x_log","y_log","mean_log",
                               "lnFC","abs_lnFC","log2FC","FC","direction")]
write.csv(combined_df, "output/global_scatter/COMBINED_all_pairs_diffs.csv", row.names = FALSE)

message("Done. Outputs in ./output and ./output/global_scatter")

```


```{r}
# --- helper to compute & write "most different genes" tables ---
write_pair_diff_csv <- function(
  obj, cond1, cond2,
  out_dir   = "output/global_scatter",
  topK      = 100,                 # how many to export in the top file
  min_mean  = 0,                   # filter tiny/noisy genes by mean log expr
  rank_by   = c("abs_lnFC","lnFC"),# ranking metric
  write_full = TRUE                # also write the full (unfiltered) table
) {
  rank_by <- match.arg(rank_by)

  mat <- as.matrix(GetAssayData(obj, slot = "data"))  # log-normalized (ln scale)
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    gene   = rownames(mat),
    x_log  = mat[, cond1],
    y_log  = mat[, cond2],
    mean_log = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_log >= min_mean, , drop = FALSE]

  # Differences on log scale
  df$lnFC     <- df$y_log - df$x_log                   # natural log fold-change
  df$abs_lnFC <- abs(df$lnFC)
  df$log2FC   <- df$lnFC / log(2)                      # convert to log2
  df$FC       <- exp(df$lnFC)                          # linear fold-change
  df$direction <- ifelse(df$lnFC > 0, paste0("up in ", cond2),
                         ifelse(df$lnFC < 0, paste0("up in ", cond1), "tie"))

  # order & rank
  ord_col <- if (rank_by == "abs_lnFC") "abs_lnFC" else "lnFC"
  df <- df[order(df[[ord_col]], decreasing = TRUE), ]
  df$rank <- seq_len(nrow(df))

  # nice column order
  df <- df[, c("rank","gene",
               "x_log","y_log","mean_log",
               "lnFC","abs_lnFC","log2FC","FC","direction")]

  # write CSVs
  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  short_name <- paste0("TOP", topK, "_", cond2, "_vs_", cond1, ".csv")
  full_name  <- paste0("ALL_", cond2, "_vs_", cond1, ".csv")
  utils::write.csv(head(df, topK),
                   file = file.path(out_dir, short_name), row.names = FALSE)
  if (write_full) {
    utils::write.csv(df, file = file.path(out_dir, full_name), row.names = FALSE)
  }
  invisible(df)
}
```

```{r}
# ---- Setup ----
suppressPackageStartupMessages({
  library(Seurat)
  library(ggplot2)
  library(ggrepel)
  library(cowplot)
  library(pheatmap)
})
theme_set(theme_cowplot())
set.seed(123)

# ---- Input object & identities ----
Idents(integrated_obj) <- "condition"
conds <- levels(factor(integrated_obj$condition))
stopifnot(length(conds) >= 2)

# ---- 1) Pseudobulk per condition ----
agg_cond <- AggregateExpression(
  integrated_obj,
  group.by = "condition",
  assays = "RNA",
  slot   = "data",
  return.seurat = TRUE
)
dir.create("output", showWarnings = FALSE)
message("Conditions: ", paste(agg_cond@meta.data$condition, collapse = ", "))

mat <- as.matrix(GetAssayData(agg_cond, slot = "data"))

# ---- 2) PCA ----
pca <- prcomp(t(mat), scale. = TRUE)
df  <- data.frame(pca$x, condition = agg_cond@meta.data$condition)
ggplot(df, aes(PC1, PC2, color = condition)) +
  geom_point(size = 5) +
  theme_cowplot() +
  labs(title = "Pseudobulk PCA (global): conditions")
ggsave("output/Global_PCA_conditions.pdf", width = 6, height = 5, useDingbats = FALSE)

# ---- 3) Correlation matrices and heatmaps ----
cor_pear <- cor(mat, method = "pearson", use = "pairwise.complete.obs")
cor_spea <- cor(mat, method = "spearman", use = "pairwise.complete.obs")

write.csv(cor_pear, "output/Global_correlation_Pearson_conditions.csv")
write.csv(cor_spea, "output/Global_correlation_Spearman_conditions.csv")

pheatmap(cor_pear, main = "Global pseudobulk correlation — Pearson",
         filename = "output/Global_correlation_Pearson_conditions.pdf")
pheatmap(cor_spea, main = "Global pseudobulk correlation — Spearman",
         filename = "output/Global_correlation_Spearman_conditions.pdf")

pairs_tab <- do.call(rbind, combn(colnames(mat), 2, FUN = function(pp) {
  x <- mat[, pp[1]]; y <- mat[, pp[2]]
  ct_p <- suppressWarnings(cor.test(x, y, method = "pearson"))
  ct_s <- suppressWarnings(cor.test(x, y, method = "spearman"))
  data.frame(
    cond1 = pp[1], cond2 = pp[2],
    n_genes = sum(complete.cases(x, y)),
    pearson_r = unname(ct_p$estimate),
    pearson_p = ct_p$p.value,
    spearman_r = unname(ct_s$estimate),
    spearman_p = ct_s$p.value,
    stringsAsFactors = FALSE
  )
}, simplify = FALSE))
write.csv(pairs_tab, "output/Global_pairwise_correlations.csv", row.names = FALSE)
print(pairs_tab)

# ---- Helper: remove 45° line from CellScatter ----
.rm_abline <- function(p) {
  keep <- vapply(p$layers, function(L) !inherits(L$geom, "GeomAbline"), logical(1))
  p$layers <- p$layers[keep]
  p
}

# ---- 4) Built-in style scatter plot with LabelPoints ----
plot_scatter_pair_builtin <- function(
  obj, cond1, cond2,
  topN = 10,
  rank_metric = c("abs_logFC", "logFC"),
  min_mean = 0,
  show_corr = TRUE,
  corr_method = c("pearson","spearman"),
  label_top = TRUE,
  pt.size = 0.2,
  pt.alpha = 0.5,
  top_pt.size = 0.8,
  top_pt.alpha = 0.95,
  top_pt.col = "firebrick",
  line_size_top = 0.2,
  seed = 123
) {
  rank_metric <- match.arg(rank_metric)
  corr_method <- match.arg(corr_method)
  set.seed(seed)

  mat <- as.matrix(GetAssayData(obj, slot = "data"))
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    x = mat[, cond1],
    y = mat[, cond2],
    gene = rownames(mat),
    mean_xy = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_xy >= min_mean, , drop = FALSE]

  df$delta <- df$y - df$x
  score <- if (rank_metric == "abs_logFC") abs(df$delta) else df$delta
  ord <- order(score, decreasing = TRUE, na.last = NA)
  top_genes <- df$gene[head(ord, topN)]

  # Base plot with CellScatter and top genes highlighted
  p <- CellScatter(obj, cond1, cond2, highlight = top_genes)
  p <- .rm_abline(p)
  p <- p + ggtitle(paste0(cond2, " vs ", cond1)) +
    xlab(paste0(cond1, " (log expr)")) +
    ylab(paste0(cond2, " (log expr)")) +
    theme_cowplot() + theme(aspect.ratio = 1)

  # Make base dots smaller and more transparent
  if (length(p$layers) >= 1) {
    p$layers[[1]]$aes_params$size  <- pt.size
    p$layers[[1]]$aes_params$alpha <- pt.alpha
  }

  # Overplot red points for top genes
  p <- p + geom_point(
    data = subset(df, gene %in% top_genes),
    aes(x = x, y = y),
    inherit.aes = FALSE,
    size = top_pt.size, alpha = top_pt.alpha, color = top_pt.col
  )

  # Add correlation label
  if (show_corr) {
    ct <- suppressWarnings(cor.test(df$x, df$y, method = corr_method))
    lab <- sprintf("%s r = %.3f (p = %.2g)",
                   tools::toTitleCase(corr_method), ct$estimate, ct$p.value)
    p <- p + annotate("text", x = -Inf, y = Inf, hjust = -0.05, vjust = 1.3, label = lab)
  }

  # Add gene labels with repel
  if (label_top) {
    p <- LabelPoints(plot = p, points = top_genes, repel = TRUE)
    # Make repel lines thinner
    p$layers[[length(p$layers)]]$geom_params$segment.size <- line_size_top
  }

  p
}

# ---- 5) Write per-pair CSVs for top differential genes ----
write_pair_diff_csv <- function(
  obj, cond1, cond2,
  out_dir = "output/global_scatter",
  topK = 100,
  min_mean = 0,
  rank_by = c("abs_lnFC","lnFC"),
  write_full = TRUE
) {
  rank_by <- match.arg(rank_by)
  mat <- as.matrix(GetAssayData(obj, slot = "data"))
  stopifnot(all(c(cond1, cond2) %in% colnames(mat)))

  df <- data.frame(
    gene     = rownames(mat),
    x_log    = mat[, cond1],
    y_log    = mat[, cond2],
    mean_log = rowMeans(mat[, c(cond1, cond2), drop = FALSE]),
    stringsAsFactors = FALSE
  )
  if (min_mean > 0) df <- df[df$mean_log >= min_mean, , drop = FALSE]

  df$lnFC      <- df$y_log - df$x_log
  df$abs_lnFC  <- abs(df$lnFC)
  df$log2FC    <- df$lnFC / log(2)
  df$FC        <- exp(df$lnFC)
  df$direction <- ifelse(df$lnFC > 0, paste0("up in ", cond2),
                         ifelse(df$lnFC < 0, paste0("up in ", cond1), "tie"))
  ord_col <- if (rank_by == "abs_lnFC") "abs_lnFC" else "lnFC"
  df <- df[order(df[[ord_col]], decreasing = TRUE), ]
  df$rank <- seq_len(nrow(df))
  df <- df[, c("rank","gene","x_log","y_log","mean_log","lnFC","abs_lnFC","log2FC","FC","direction")]

  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  short_name <- paste0("TOP", topK, "_", cond2, "_vs_", cond1, ".csv")
  full_name  <- paste0("ALL_", cond2, "_vs_", cond1, ".csv")
  write.csv(head(df, topK), file.path(out_dir, short_name), row.names = FALSE)
  if (write_full) write.csv(df, file.path(out_dir, full_name), row.names = FALSE)
  invisible(df)
}

# ---- 6) Generate all pairwise plots and CSVs ----
dir.create("output/global_scatter", recursive = TRUE, showWarnings = FALSE)
pairs <- combn(colnames(agg_cond), 2, simplify = FALSE)
all_pairs <- lapply(pairs, function(pp) {
  cond1 <- pp[1]; cond2 <- pp[2]
  g <- plot_scatter_pair_builtin(
    obj = agg_cond, cond1 = cond1, cond2 = cond2,
    topN = 10, rank_metric = "abs_logFC",
    min_mean = 0.1, show_corr = TRUE, corr_method = "pearson", label_top = TRUE
  )
  gfile <- file.path("output/global_scatter",
                     paste0("CellScatter_GLOBAL_", cond2, "_vs_", cond1, ".pdf"))
  ggsave(gfile, g, width = 5, height = 5, useDingbats = FALSE)

  df_pair <- write_pair_diff_csv(
    obj = agg_cond, cond1 = cond1, cond2 = cond2,
    out_dir = "output/global_scatter", topK = 100, min_mean = 0.1,
    rank_by = "abs_lnFC", write_full = TRUE
  )
  df_pair$contrast <- paste0(cond2, "_vs_", cond1)
  df_pair
})

combined_df <- do.call(rbind, all_pairs)
combined_df <- combined_df[, c("contrast","rank","gene","x_log","y_log","mean_log",
                               "lnFC","abs_lnFC","log2FC","FC","direction")]
write.csv(combined_df, "output/global_scatter/COMBINED_all_pairs_diffs.csv", row.names = FALSE)

message("Done. Outputs in ./output and ./output/global_scatter")

```
```{r}
state_col <- "transfered_labels_confident"
states <- unique(integrated_obj@meta.data[[state_col]])
state_cells <- lapply(states, function(st) {
  rownames(integrated_obj@meta.data)[integrated_obj@meta.data[[state_col]] == st]
})
names(state_cells) <- states

# one Seurat object per state
objs_by_state <- setNames(
  lapply(names(state_cells), function(st) subset(integrated_obj, cells = state_cells[[st]])),
  names(state_cells)
)

# quick check: number of cells in each object
sapply(objs_by_state, ncol)


```

```{r}
# 1) Put OPC states together in the desired left→right order
state_order <- c("MES-like","AC-like","OPC-like-1","OPC-like-2","OPC-like-3","OC-like","Microglia")
obj_states$transfered_labels_confident <- factor(obj_states$transfered_labels_confident,
                                                 levels = state_order)

# 2) (Optional) Also order features by state so genes appear grouped nicely
features_use <- unlist(
  lapply(state_order, function(st)
    top_markers$gene[top_markers$cluster == st])
)

# 3) Re-plot
p_dot <- DotPlot(obj_states, features = features_use,
                 group.by = "transfered_labels_confident") +
  RotatedAxis() +
  labs(title = "Top markers per state (OPC subtypes grouped)")
p_dot

ggsave(here("output/DotPlot_top_markers_per_state.pdf"), p_dot, width = 12, height = 6)


```
```{r}
# One-state DE between two conditions
state_col <- "transfered_labels_confident"
st  <- "AC-like"       # <— choose a state
c1  <- "NS"            # <— condition A
c2  <- "BP_Cues"       # <— condition B

obj_st <- subset(integrated_obj, subset = !!as.name(state_col) == st)
Idents(obj_st) <- "condition"

de_st <- FindMarkers(
  obj_st, ident.1 = c2, ident.2 = c1,
  min.pct = 0.1, logfc.threshold = 0.25, test.use = "wilcox"
)

head(de_st[order(-de_st$avg_log2FC), ], 15)

# Add -log10(p) for visual emphasis
de_st$gene <- rownames(de_st)
de_st$neglog10p <- -log10(de_st$p_val_adj + 1e-300)

volcanoggplot(de_st, aes(x = avg_log2FC, y = neglog10p)) +
  geom_point(alpha = 0.6) +
  geom_vline(xintercept = c(-0.25, 0.25), linetype = "dashed", color = "grey50") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey50") +
  theme_minimal() +
  labs(
    title = paste0(st, ": ", c2, " vs ", c1),
    x = "Average log2 fold change",
    y = "-log10 adjusted p-value"
  )

```
```{r}
# --- Helper: pseudobulk mean (log-normalized) per gene for a state × condition ---
pseudobulk_state <- function(seu, state, cond) {
  obj <- subset(seu, subset = transfered_labels_confident == state & condition == cond)
  if (ncol(obj) < 5) stop(paste("Too few cells in", state, cond))
  Matrix::rowMeans(GetAssayData(obj, slot = "data"))
}

# --- Compute effect sizes for one state between two conditions ---
effect_size_table <- function(seu, state, cond1, cond2) {
  m1 <- pseudobulk_state(seu, state, cond1)
  m2 <- pseudobulk_state(seu, state, cond2)
  common <- intersect(names(m1), names(m2))
  m1 <- m1[common]; m2 <- m2[common]
  # effect size: difference on log scale ≈ log2FC
  df <- data.frame(
    gene = common,
    meanA = m1, meanB = m2,
    avg_log2FC = (m2 - m1) / log(2),                 # log2 fold-change
    mean_ab = 0.5 * (m1 + m2),                       # average log-expression
    stringsAsFactors = FALSE
  )
  df[order(-abs(df$avg_log2FC)), ]
}

# --- A) MA plot (effect size only) ---
plot_ma <- function(df, title = "") {
  ggplot(df, aes(x = mean_ab, y = avg_log2FC)) +
    geom_hline(yintercept = 0, color = "grey60") +
    geom_point(alpha = 0.5, size = 0.6) +
    labs(x = "Average log-normalized expression",
         y = "log2 fold change (cond2 vs cond1)",
         title = title) +
    theme_minimal()
}

# --- B) Ranked top-|log2FC| bar chart (effect size only) ---
plot_top_fc <- function(df, topN = 15, title = "") {
  top <- head(df, topN)
  ggplot(top, aes(x = reorder(gene, avg_log2FC), y = avg_log2FC, fill = avg_log2FC > 0)) +
    geom_col() +
    coord_flip() +
    scale_fill_manual(values = c("TRUE"="#1b9e77","FALSE"="#d95f02"), guide = "none") +
    labs(x = NULL, y = "log2 fold change (cond2 vs cond1)", title = title) +
    theme_minimal()
}

# ===== Usage: pick a state & conditions =====
st  <- "MES-like"
c1  <- "BP_Cues"
c2  <- "NS"

es <- effect_size_table(integrated_obj, st, c1, c2)

p_ma  <- plot_ma(es,  paste0(st, "  (", c2, " vs ", c1, ")"))
p_bar <- plot_top_fc(es, topN = 12, title = paste0(st, "  top |log2FC| (", c2, " vs ", c1, ")"))

# Save if you want
ggsave(here::here("output", paste0("MA_", st, "_", c2, "_vs_", c1, ".pdf")),  p_ma,  width = 5, height = 4)
ggsave(here::here("output", paste0("TopFC_", st, "_", c2, "_vs_", c1, ".pdf")), p_bar, width = 5, height = 4)
```


```{r}
# --- DE within one state using FindMarkers (cond2 vs cond1) ---
state_col <- "transfered_labels_confident"
st  <- "MES-like"   # <- pick a state
c1  <- "NS"        # <- condition A
c2  <- "BP_Cues"   # <- condition B

obj_st <- subset(integrated_obj, subset = !!as.name(state_col) == st)
Idents(obj_st) <- "condition"

de_st <- FindMarkers(
  obj_st,
  ident.1 = c2, ident.2 = c1,      # direction: up = higher in c2
  test.use = "wilcox",
  min.pct = 0.10,
  logfc.threshold = 0.25
)

de_st$gene <- rownames(de_st)
de_st <- de_st[order(-abs(de_st$avg_log2FC)), ]

# save table
# Make sure the folder exists
outdir <- here("output", "de_within_state")
dir.create(outdir, showWarnings = FALSE, recursive = TRUE)

# Construct the full path inside that folder
outfile <- file.path(outdir, paste0("DE_", st, "_", c2, "_vs_", c1, ".csv"))

# Save table
write.csv(de_st, outfile, row.names = FALSE)
```

